{"version":3,"file":"index.js","sources":["../src/service/number_utils.ts","../src/service/range_handler.ts"],"sourcesContent":["export const isNumber = (val:any) => {\n    return /^-?\\d+$/.test(val);\n}","import { IRange } from \"../model/IRange\";\nimport { isNumber } from \"./number_utils\";\n\n\n/*\n      Sample result:\n\n      lockRangesProcessed: [\n        { from: 7, to: 13 },\n        { from: 7, to: 12 },\n        { from: 7, to: 11 },\n        { from: 8, to: 11 },\n        { from: 10, to: 14 }\n      ]\n \n*/\nconst sortRanges = (ranges:Array<{from:number, to:number}>) => {\n  return ranges.slice().sort((a, b) => {\n    const aLength = a.to - a.from;\n    const bLength = b.to - b.from;\n\n    //lower from comes first\n    if(a.from > b.from){\n      return 1;\n    }\n\n    if(a.from === b.from){\n\n      // bigger ranges comes first\n      if((a.from + aLength) > (b.from + bLength)){\n        return -1;\n      }\n\n      if((a.from + aLength) === (b.from + bLength)){\n        return 0;\n      }\n\n      if((a.from + aLength) < (b.from + bLength)){\n        return +1;\n      }\n    }\n\n    return -1;\n\n    \n  })\n};\n\nconst getAvailableRanges = (\n  lockRanges:Array<IRange>, \n  selection:IRange|null, \n  limit:IRange = {from:undefined, to:undefined}\n  ):Array<IRange> => {\n    \n    //pre-process\n    \n    //Step 1: Guarantee only numbers || undefined\n    let lockRangesProcessed:Array<IRange> = lockRanges.map(lockRange => {\n\n      lockRange.from = !isNumber(lockRange.from) ? undefined : lockRange.from;\n      lockRange.to = !isNumber(lockRange.to) ? undefined : lockRange.to;\n\n      // Step 2: Guarantee Ranges Direction: From <= To\n      if(isNumber(lockRange.from) && isNumber(lockRange.to)){\n        const tmpLockRange = {...lockRange};\n        lockRange.from = Math.min(tmpLockRange.from as number, tmpLockRange.to as number);\n        lockRange.to = Math.max(tmpLockRange.from as number, tmpLockRange.to as number);\n      }\n      \n      return lockRange;\n\n    })\n\n    //Step 1: Guarantee only numbers || undefined\n    let selectionProcessed = {\n        from: !isNumber(selection?.from) ? undefined : selection?.from,\n        to: !isNumber(selection?.to) ? undefined : selection?.to\n    }\n\n    // Step 2: Guarantee Ranges Direction: From <= To\n    if(isNumber(selectionProcessed.from) && isNumber(selectionProcessed.to)){\n      const tmpSelectionProcessed = {...selectionProcessed};\n      selectionProcessed.from = Math.min(tmpSelectionProcessed.from as number, tmpSelectionProcessed.to as number);\n      selectionProcessed.to = Math.max(tmpSelectionProcessed.from as number, tmpSelectionProcessed.to as number);\n    }\n    \n    //Step 1: Guarantee only numbers || undefined\n    let limitProcessed = {\n        from: !isNumber(limit?.from) ? undefined : limit?.from,\n        to: !isNumber(limit?.to) ? undefined : limit?.to\n    }\n    // Step 2: Guarantee Ranges Direction: From <= To\n    if(isNumber(limitProcessed.from) && isNumber(limitProcessed.to)){\n      const tmpLimitProcessed = {...limitProcessed};\n      limitProcessed.from = Math.min(tmpLimitProcessed.from as number, tmpLimitProcessed.to as number);\n      limitProcessed.to = Math.max(tmpLimitProcessed.from as number, tmpLimitProcessed.to as number);\n    }\n\n    //Step 3: Extract infinity values representation\n    const allFromLockRangesArr = lockRangesProcessed.map(lockRange => lockRange.from);\n    const allFromNumbers = [...allFromLockRangesArr, selectionProcessed?.from, limitProcessed?.from].filter(value => value !== undefined) as Array<number>;\n\n    const allToLockRangesArr = lockRangesProcessed.map(lockRange => lockRange.to);\n    const allToNumbers = [...allToLockRangesArr, selectionProcessed?.to, limitProcessed?.to].filter(value => value !== undefined) as Array<number>;\n    \n    const allNumbers = [...allFromNumbers, ...allToNumbers];\n    let max = 0;\n    let min = 0;\n\n    if(allNumbers.length > 0){\n      max = Math.max(...allNumbers);\n      min = Math.min(...allNumbers);\n    }\n\n    const absMax = Math.abs(max);\n    const absMin = Math.abs(min);\n\n    const PositiveInfinity = Math.max(absMax, absMin) + 1;\n    const NegativeInfinity = -PositiveInfinity;\n    \n    // console.log({PositiveInfinity});\n    // console.log({NegativeInfinity});\n    //Step 4: Replace undefined for its infinity representation\n\n    lockRangesProcessed = lockRangesProcessed.map(lockRange => {\n      lockRange.from = !isNumber(lockRange.from) ? NegativeInfinity : lockRange.from;\n      lockRange.to = !isNumber(lockRange.to) ? PositiveInfinity : lockRange.to;\n\n      return lockRange;\n    })\n\n    selectionProcessed = {\n      from: !isNumber(selectionProcessed.from) ? NegativeInfinity : selectionProcessed.from,\n      to: !isNumber(selectionProcessed.to) ? PositiveInfinity : selectionProcessed.to\n  }\n    \n    limitProcessed = {\n    from: !isNumber(limitProcessed.from) ? NegativeInfinity : limitProcessed.from,\n    to: !isNumber(limitProcessed.to) ? PositiveInfinity : limitProcessed.to\n}\n\n//Step 5: Sort LockRanges\nlockRangesProcessed = sortRanges(lockRangesProcessed as any);\n\n// console.log({selectionProcessed});\n// console.log({limitProcessed});\n// console.log({lockRangesProcessed});\n\n// Step 6: Call processFreeRangesFromSelection \nconst result = processFreeRangesFromSelection(lockRangesProcessed as any, selectionProcessed  as any, [], limitProcessed  as any);\n\n// Step 7: Replace Infinity representations with undefined\nconst resultProcessed = result.map(unprocessedRange => {\n\n  const range = {\n    from: unprocessedRange.from === NegativeInfinity ? undefined : unprocessedRange.from,\n    to: unprocessedRange.to === PositiveInfinity ? undefined : unprocessedRange.to,\n  }\n  \n  // Step 8: return processed result\n  return range;\n})\n\n// console.log({resultProcessed});\n\n    return resultProcessed;\n  }\n\n \n  const cutRangeByLimit = (range:{from:number, to:number}, limit:{from:number, to:number}) => {\n    const cutResult = {\n      from: range.from < limit.from ? limit.from : range.from,\n      to: range.to > limit.to ? limit.to : range.to,\n    }\n  \n    return cutResult;\n  }\n\nconst processFreeRangesFromSelection = (\nlockRanges:Array<{from:number, to:number}>, \nselection:{from:number, to:number}|null, \nresultFreeRanges:Array<{from:number, to:number}>,\nlimit:{from:number, to:number}\n):Array<{from:number, to:number}> => {\n\nlet result = resultFreeRanges;\n  \nif(selection === null || lockRanges.length === 0)\n{\n  if(selection !== null && !resultFreeRanges.some(range => range.from === selection?.from && range.to === selection?.to)){\n       result.push(selection);\n  }\n  \n  //filter all results that cross limit area\n  result = result.filter(range => range.from <= limit.to && range.to >= limit.from);\n  \n  //cut them by its limit\n  result = result.map((range) => cutRangeByLimit(range, limit));\n    \n  return result;\n}\n  \n  const selectionRangeSize = selection.to - selection.from;\n  \n  // if selection starts within a lock range\n  if(selection.from >= lockRanges[0].from\n    && selection.from <=  lockRanges[0].to) {\n      \n      //if selection is completely inside of a readonly area\n      if(selection.from + selectionRangeSize <= lockRanges[0].to){\n        selection = null;\n      }\n      else{\n      selection.from = lockRanges[0].to + 1;\n    }\n      \n    }\n\n    //if selection doesn't start within a lockrange but cross the lockrange\n    else if(selection.from < lockRanges[0].from && (selection.from + selectionRangeSize) >= lockRanges[0].from){\n      \n      const selectionTo = selection.to;\n      \n      //cut selection:: selectionRange.to = readOnlyRanges[0].from-1;\n      const partialResult = {\n        from: selection.from,\n        to: lockRanges[0].from-1\n      }\n      \n      // save the valid selection\n      resultFreeRanges.push(partialResult);\n      \n      // if there is some selection leftover to evaluate\n      if(selectionTo > lockRanges[0].to){\n        selection.from = lockRanges[0].to+1;\n      }\n      else{\n        selection = null;\n      }\n      \n      }\n\n      lockRanges.shift();\n      return processFreeRangesFromSelection(lockRanges, selection, resultFreeRanges, limit);\n\n}\n\nexport { getAvailableRanges }"],"names":["isNumber","val","test","processFreeRangesFromSelection","lockRanges","selection","resultFreeRanges","limit","result","length","some","range","from","to","push","filter","map","cutRangeByLimit","selectionRangeSize","selectionTo","partialResult","shift","undefined","lockRangesProcessed","lockRange","tmpLockRange","__assign","Math","min","max","selectionProcessed","tmpSelectionProcessed","limitProcessed","tmpLimitProcessed","allFromLockRangesArr","allFromNumbers","__spreadArray","value","allToLockRangesArr","allToNumbers","allNumbers","absMax","abs","absMin","PositiveInfinity","NegativeInfinity","slice","sort","a","b","aLength","bLength","unprocessedRange"],"mappings":"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"}