{"version":3,"file":"index.es.js","sources":["../src/service/number_utils.ts","../src/service/range_handler.ts"],"sourcesContent":["export const isNumber = (val:any) => {\n    return /^-?\\d+$/.test(val);\n}","import { IRange } from \"../model/IRange\";\nimport { isNumber } from \"./number_utils\";\n\n\n/*\n      Sample result:\n\n      lockRangesProcessed: [\n        { from: 7, to: 13 },\n        { from: 7, to: 12 },\n        { from: 7, to: 11 },\n        { from: 8, to: 11 },\n        { from: 10, to: 14 }\n      ]\n \n*/\nconst sortRanges = (ranges:Array<{from:number, to:number}>) => {\n  return ranges.slice().sort((a, b) => {\n    const aLength = a.to - a.from;\n    const bLength = b.to - b.from;\n\n    //lower from comes first\n    if(a.from > b.from){\n      return 1;\n    }\n\n    if(a.from === b.from){\n\n      // bigger ranges comes first\n      if((a.from + aLength) > (b.from + bLength)){\n        return -1;\n      }\n\n      if((a.from + aLength) === (b.from + bLength)){\n        return 0;\n      }\n\n      if((a.from + aLength) < (b.from + bLength)){\n        return +1;\n      }\n    }\n\n    return -1;\n\n    \n  })\n};\n\nconst getAvailableRanges = (\n  lockRanges:Array<IRange>, \n  selection:IRange|null, \n  limit:IRange = {from:undefined, to:undefined}\n  ):Array<IRange> => {\n    \n    //pre-process\n    \n    //Step 1: Guarantee only numbers || undefined\n    let lockRangesProcessed:Array<IRange> = lockRanges.map(lockRange => {\n\n      lockRange.from = !isNumber(lockRange.from) ? undefined : lockRange.from;\n      lockRange.to = !isNumber(lockRange.to) ? undefined : lockRange.to;\n\n      // Step 2: Guarantee Ranges Direction: From <= To\n      if(isNumber(lockRange.from) && isNumber(lockRange.to)){\n        const tmpLockRange = {...lockRange};\n        lockRange.from = Math.min(tmpLockRange.from as number, tmpLockRange.to as number);\n        lockRange.to = Math.max(tmpLockRange.from as number, tmpLockRange.to as number);\n      }\n      \n      return lockRange;\n\n    })\n\n    //Step 1: Guarantee only numbers || undefined\n    let selectionProcessed = {\n        from: !isNumber(selection?.from) ? undefined : selection?.from,\n        to: !isNumber(selection?.to) ? undefined : selection?.to\n    }\n\n    // Step 2: Guarantee Ranges Direction: From <= To\n    if(isNumber(selectionProcessed.from) && isNumber(selectionProcessed.to)){\n      const tmpSelectionProcessed = {...selectionProcessed};\n      selectionProcessed.from = Math.min(tmpSelectionProcessed.from as number, tmpSelectionProcessed.to as number);\n      selectionProcessed.to = Math.max(tmpSelectionProcessed.from as number, tmpSelectionProcessed.to as number);\n    }\n    \n    //Step 1: Guarantee only numbers || undefined\n    let limitProcessed = {\n        from: !isNumber(limit?.from) ? undefined : limit?.from,\n        to: !isNumber(limit?.to) ? undefined : limit?.to\n    }\n    // Step 2: Guarantee Ranges Direction: From <= To\n    if(isNumber(limitProcessed.from) && isNumber(limitProcessed.to)){\n      const tmpLimitProcessed = {...limitProcessed};\n      limitProcessed.from = Math.min(tmpLimitProcessed.from as number, tmpLimitProcessed.to as number);\n      limitProcessed.to = Math.max(tmpLimitProcessed.from as number, tmpLimitProcessed.to as number);\n    }\n\n    //Step 3: Extract infinity values representation\n    const allFromLockRangesArr = lockRangesProcessed.map(lockRange => lockRange.from);\n    const allFromNumbers = [...allFromLockRangesArr, selectionProcessed?.from, limitProcessed?.from].filter(value => value !== undefined) as Array<number>;\n\n    const allToLockRangesArr = lockRangesProcessed.map(lockRange => lockRange.to);\n    const allToNumbers = [...allToLockRangesArr, selectionProcessed?.to, limitProcessed?.to].filter(value => value !== undefined) as Array<number>;\n    \n    const allNumbers = [...allFromNumbers, ...allToNumbers];\n    let max = 0;\n    let min = 0;\n\n    if(allNumbers.length > 0){\n      max = Math.max(...allNumbers);\n      min = Math.min(...allNumbers);\n    }\n\n    const absMax = Math.abs(max);\n    const absMin = Math.abs(min);\n\n    const PositiveInfinity = Math.max(absMax, absMin) + 1;\n    const NegativeInfinity = -PositiveInfinity;\n    \n    // console.log({PositiveInfinity});\n    // console.log({NegativeInfinity});\n    //Step 4: Replace undefined for its infinity representation\n\n    lockRangesProcessed = lockRangesProcessed.map(lockRange => {\n      lockRange.from = !isNumber(lockRange.from) ? NegativeInfinity : lockRange.from;\n      lockRange.to = !isNumber(lockRange.to) ? PositiveInfinity : lockRange.to;\n\n      return lockRange;\n    })\n\n    selectionProcessed = {\n      from: !isNumber(selectionProcessed.from) ? NegativeInfinity : selectionProcessed.from,\n      to: !isNumber(selectionProcessed.to) ? PositiveInfinity : selectionProcessed.to\n  }\n    \n    limitProcessed = {\n    from: !isNumber(limitProcessed.from) ? NegativeInfinity : limitProcessed.from,\n    to: !isNumber(limitProcessed.to) ? PositiveInfinity : limitProcessed.to\n}\n\n//Step 5: Sort LockRanges\nlockRangesProcessed = sortRanges(lockRangesProcessed as any);\n\n// console.log({selectionProcessed});\n// console.log({limitProcessed});\n// console.log({lockRangesProcessed});\n\n// Step 6: Call processFreeRangesFromSelection \nconst result = processFreeRangesFromSelection(lockRangesProcessed as any, selectionProcessed  as any, [], limitProcessed  as any);\n\n// Step 7: Replace Infinity representations with undefined\nconst resultProcessed = result.map(unprocessedRange => {\n\n  const range = {\n    from: unprocessedRange.from === NegativeInfinity ? undefined : unprocessedRange.from,\n    to: unprocessedRange.to === PositiveInfinity ? undefined : unprocessedRange.to,\n  }\n  \n  // Step 8: return processed result\n  return range;\n})\n\n// console.log({resultProcessed});\n\n    return resultProcessed;\n  }\n\n \n  const cutRangeByLimit = (range:{from:number, to:number}, limit:{from:number, to:number}) => {\n    const cutResult = {\n      from: range.from < limit.from ? limit.from : range.from,\n      to: range.to > limit.to ? limit.to : range.to,\n    }\n  \n    return cutResult;\n  }\n\nconst processFreeRangesFromSelection = (\nlockRanges:Array<{from:number, to:number}>, \nselection:{from:number, to:number}|null, \nresultFreeRanges:Array<{from:number, to:number}>,\nlimit:{from:number, to:number}\n):Array<{from:number, to:number}> => {\n\nlet result = resultFreeRanges;\n  \nif(selection === null || lockRanges.length === 0)\n{\n  if(selection !== null && !resultFreeRanges.some(range => range.from === selection?.from && range.to === selection?.to)){\n       result.push(selection);\n  }\n  \n  //filter all results that cross limit area\n  result = result.filter(range => range.from <= limit.to && range.to >= limit.from);\n  \n  //cut them by its limit\n  result = result.map((range) => cutRangeByLimit(range, limit));\n    \n  return result;\n}\n  \n  const selectionRangeSize = selection.to - selection.from;\n  \n  // if selection starts within a lock range\n  if(selection.from >= lockRanges[0].from\n    && selection.from <=  lockRanges[0].to) {\n      \n      //if selection is completely inside of a readonly area\n      if(selection.from + selectionRangeSize <= lockRanges[0].to){\n        selection = null;\n      }\n      else{\n      selection.from = lockRanges[0].to + 1;\n    }\n      \n    }\n\n    //if selection doesn't start within a lockrange but cross the lockrange\n    else if(selection.from < lockRanges[0].from && (selection.from + selectionRangeSize) >= lockRanges[0].from){\n      \n      const selectionTo = selection.to;\n      \n      //cut selection:: selectionRange.to = readOnlyRanges[0].from-1;\n      const partialResult = {\n        from: selection.from,\n        to: lockRanges[0].from-1\n      }\n      \n      // save the valid selection\n      resultFreeRanges.push(partialResult);\n      \n      // if there is some selection leftover to evaluate\n      if(selectionTo > lockRanges[0].to){\n        selection.from = lockRanges[0].to+1;\n      }\n      else{\n        selection = null;\n      }\n      \n      }\n\n      lockRanges.shift();\n      return processFreeRangesFromSelection(lockRanges, selection, resultFreeRanges, limit);\n\n}\n\nexport { getAvailableRanges }"],"names":["isNumber","val","test","getAvailableRanges","lockRanges","selection","limit","from","undefined","to","lockRangesProcessed","map","lockRange","tmpLockRange","__assign","Math","min","max","selectionProcessed","tmpSelectionProcessed","limitProcessed","tmpLimitProcessed","allFromLockRangesArr","allFromNumbers","__spreadArray","filter","value","allToLockRangesArr","allToNumbers","allNumbers","length","absMax","abs","absMin","PositiveInfinity","NegativeInfinity","slice","sort","a","b","aLength","bLength","processFreeRangesFromSelection","unprocessedRange","resultFreeRanges","result","some","range","push","cutRangeByLimit","selectionRangeSize","selectionTo","partialResult","shift"],"mappings":"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"}