import{br as M,bs as P,bt as V,bu as Tt,bv as N,bw as Et,bx as Ht,by as Bt,bz as Rt,bA as Dt,bB as L,aJ as E,bC as _,bD as H,bE as B,bF as k,bG as X,bH as Lt,bI as rt,bJ as O,bK as nt,bL as W,f as I,bM as S,bN as ot,bO as Pt,E as D,bP as Wt,bp as It,I as T,d as _t,h as Ot,c as Ft,K as Ut,al as zt,O as Nt,o as Xt}from"./index-8aSAdiyM.js";import{t as Yt}from"./index-izglcM0V.js";const it={...V,...P,textOffsetFromCenter:0},at=M(it),ct={...it},lt=M(ct),Gt={...N,...P,...V,...Tt},ut=M(Gt),qt={...N},ht=M(qt),Kt={...P,brushWeight:3},dt=M(Kt),ft={...Et},Jt=M(ft),$t={...P,...N,points:5},gt=M($t),Vt={...P},pt=M(Vt),kt={...P,...N,...V},xt=M(kt),q={arrow:lt,circle:Rt,cross:ut,ellipse:Bt,image:ht,line:at,rect:Ht,scribble:dt,square:Jt,star:gt,triangle:pt,uturn:xt},jt=new Set(["drawTextAreaMatte","drawText","drawTextArea","textHitbox","startTextAreaEdit","name","draw","drawShape","hitbox","shapeHitbox","efficientHitbox","getBoundingBox","getCenterPoint"]),mt=n=>{if(!n.textArea)return;const{textOffsetFromCenter:t,start:e,end:o}=n,s=Dt(e,o),r=t*Math.cos(s),a=t*Math.sin(s),c=(e.x+o.x)/2+r,l=(e.y+o.y)/2+a;return{x:c,y:l}},Qt=n=>t=>{const{start:e,end:o,lineWidth:s,fillColor:r,dash:a=[],fillGradient:c}=n;if(s!==0){if(t.save(),t.beginPath(),t.moveTo(e.x,e.y),t.lineTo(o.x,o.y),t.lineWidth=s,t.strokeStyle=r,c&&c.length>=2){const l=t.createLinearGradient(e.x,e.y,o.x,o.y);c.forEach(({offset:i,color:u})=>{l.addColorStop(i,u)}),t.strokeStyle=l}t.setLineDash(a),t.stroke(),t.closePath(),t.restore()}},Zt=n=>t=>_(n,t),j=n=>()=>{const{start:t,end:e,lineWidth:o}=n,s=Math.min(t.x,e.x)-o/2,r=Math.min(t.y,e.y)-o/2,a=Math.max(t.x,e.x)+o/2,c=Math.max(t.y,e.y)+o/2;return E({at:{x:s,y:r},width:a-s,height:c-r})},te=n=>{const{start:t,end:e,lineWidth:o}=n,s=Math.hypot(e.x-t.x,e.y-t.y),r=Math.atan2(e.y-t.y,e.x-t.x),a=Math.abs(Math.cos(r))+Math.abs(Math.sin(r)),c=Math.min(50,s*a),l=Math.ceil(s/c),i=(e.x-t.x)/s,u=(e.y-t.y)/s;return d=>L(j(n)(),d)?Array.from({length:l},(p,g)=>{const m=t.x+i*c*g,w=t.y+u*c*g,y=m+i*c,x=w+u*c,A=Math.min(m,y)-o/2,C=Math.min(w,x)-o/2,b=Math.abs(y-m)+o,G=Math.abs(x-w)+o;return E({at:{x:A,y:C},width:b,height:G})}).some(p=>L(p,d)):!1},R=n=>{if(n.lineWidth&&n.lineWidth<0)throw new Error("lineWidth must be positive");const t=at(n),e=mt(t),o=H(e,t.textArea),s=Zt(t),r=te(t),a=u=>(o==null?void 0:o.textHitbox(u))||s(u),c=j(t),l=Qt(t);return B({name:"line",draw:u=>{l(u),o==null||o.drawTextArea(u)},drawShape:l,hitbox:a,shapeHitbox:s,efficientHitbox:r,getBoundingBox:c,...o})},ee=n=>t=>{const{pointA:e,pointB:o,pointC:s,fillColor:r,stroke:a,fillGradient:c}=n;if(t.beginPath(),t.moveTo(e.x,e.y),t.lineTo(o.x,o.y),t.lineTo(s.x,s.y),c&&c.length>=2){const l={x:(o.x+s.x)/2,y:(o.y+s.y)/2},i=t.createLinearGradient(l.x,l.y,e.x,e.y);c.forEach(({offset:u,color:d})=>{i.addColorStop(u,d)}),t.fillStyle=i}else t.fillStyle=r;t.fill(),t.closePath(),a&&(t.lineWidth=a.lineWidth,t.strokeStyle=a.color,t.setLineDash(a.dash??[]),t.stroke(),t.setLineDash([]))},ne=n=>t=>{const{pointA:e,pointB:o,pointC:s,stroke:r}=n,{x:a,y:c}=t,l=.5*(-o.y*s.x+e.y*(-o.x+s.x)+e.x*(o.y-s.y)+o.x*s.y),i=1/(2*l)*(e.y*s.x-e.x*s.y+(s.y-e.y)*a+(e.x-s.x)*c),u=1/(2*l)*(e.x*o.y-e.y*o.x+(e.y-o.y)*a+(o.x-e.x)*c),d=i>0&&u>0&&1-i-u>0;if(!r)return d;const h={start:e,end:o,...r},f={start:o,end:s,...r},p={start:s,end:e,...r},g=_(h,t)||_(f,t)||_(p,t);return d||g},yt=n=>()=>{const{pointA:t,pointB:e,pointC:o}=n,s=Math.min(t.x,e.x,o.x),r=Math.min(t.y,e.y,o.y),a=Math.max(t.x,e.x,o.x),c=Math.max(t.y,e.y,o.y);return E({at:{x:s,y:r},width:a-s,height:c-r})},oe=n=>t=>L(yt(n)(),t),Y=n=>{const t=pt(n),e=yt(t),o=k(e()),s=H(o,t.textArea),r=ne(t),a=oe(t),c=u=>(s==null?void 0:s.textHitbox(u))||r(u),l=ee(t);return B({name:"triangle",draw:u=>{l(u),s==null||s.drawTextArea(u)},drawShape:l,hitbox:c,shapeHitbox:r,efficientHitbox:a,getBoundingBox:e,...s})},se=n=>{var d;const{start:t,end:e,lineWidth:o,fillGradient:s,fillColor:r}=n,a=X({start:t,end:e,lineWidth:o}),{arrowHeadHeight:c}=Lt(o),l=Math.atan2(e.y-t.y,e.x-t.x),i=R({...n,end:{x:e.x-c*Math.cos(l)+Math.cos(l),y:e.y-c*Math.sin(l)+Math.sin(l)}}),u=Y({...a,fillColor:s&&s.length?(d=s.at(-1))==null?void 0:d.color:r});return h=>{i.drawShape(h),u.drawShape(h)}},re=n=>{const{start:t,end:e,lineWidth:o}=n,s=X({start:t,end:e,lineWidth:o}),r=R(n),a=Y(s);return c=>r.hitbox(c)||a.hitbox(c)},ie=n=>()=>{const{at:t,width:e,height:o}=j(n)(),s={x:t.x,y:t.y},r={x:t.x+e,y:t.y+o},{start:a,end:c,lineWidth:l}={...ct,...n},i=X({start:a,end:c,lineWidth:l}),u=Math.min(s.x,r.x,i.pointA.x,i.pointB.x,i.pointC.x),d=Math.max(s.x,r.x,i.pointA.x,i.pointB.x,i.pointC.x),h=Math.min(s.y,r.y,i.pointA.y,i.pointB.y,i.pointC.y),f=Math.max(s.y,r.y,i.pointA.y,i.pointB.y,i.pointC.y);return E({at:{x:u,y:h},width:d-u,height:f-h})},ae=n=>{const{start:t,end:e,lineWidth:o}=n,s=X({start:t,end:e,lineWidth:o}),r=R(n),a=Y(s);return c=>r.efficientHitbox(c)||a.efficientHitbox(c)},Q=n=>{if(n.lineWidth&&n.lineWidth<0)throw new Error("width must be positive");const t=lt(n),e=mt(t),o=H(e,t.textArea),s=se(t),r=re(t),a=ae(t),c=u=>(o==null?void 0:o.textHitbox(u))||r(u),l=ie(t);return B({name:"arrow",draw:u=>{s(u),o==null||o.drawTextArea(u)},drawShape:s,hitbox:c,shapeHitbox:r,efficientHitbox:a,getBoundingBox:l,...o})},ce=n=>{const{at:t,size:e,rotation:o,fillColor:s,lineWidth:r,borderRadius:a}=n,c=r/2,[l,i,u,d]=rt(a);return h=>{h.save(),h.translate(t.x,t.y),h.rotate(o),O({at:{x:-c,y:-e/2},width:r,height:e/2-c,fillColor:s,borderRadius:[l,l,0,0]})(h),O({at:{x:-e/2,y:-c},width:e,height:r,fillColor:s,borderRadius:[d,i,i,d]})(h),O({at:{x:-c,y:c},width:r,height:e/2-c,fillColor:s,borderRadius:[0,0,u,u]})(h),h.restore()}},le=n=>{const{at:t,size:e,lineWidth:o,borderRadius:s,...r}=n,a=o/2,[c,l,i,u]=rt(s),d=nt({...r,at:{x:t.x-e/2,y:t.y-a},width:e,height:o,borderRadius:[u,l,l,u]}),h=nt({...r,at:{x:t.x-a,y:t.y-e/2},width:o,height:e,borderRadius:[c,c,i,i]});return f=>d(f)||h(f)},bt=n=>()=>{const{at:t,size:e}=n;return E({at:{x:t.x-e/2,y:t.y-e/2},width:e,height:e})},ue=n=>t=>L(bt(n)(),t),he=n=>{if(n.lineWidth&&n.lineWidth<0)throw new Error("lineWidth must be positive");const t=ut(n),e=H(t.at,t.textArea),o=ce(t),s=i=>{o(i),e==null||e.drawTextArea(i)},r=le(t),a=ue(t),c=i=>(e==null?void 0:e.textHitbox(i))||r(i),l=bt(t);return B({name:"cross",draw:s,drawShape:o,hitbox:c,shapeHitbox:r,efficientHitbox:a,getBoundingBox:l,...e})},K=new Map,de=async(n,t)=>new Promise(e=>{K.has(n)&&e(K.get(n));const o={image:null,loading:!0,error:!1};K.set(n,o);const s=new Image;s.onload=()=>{var r;o.image=s,o.loading=!1,(r=t.onLoad)==null||r.call(t),e(o)},s.onerror=()=>{var r;o.loading=!1,o.error=!0,(r=t.onLoadError)==null||r.call(t),e(o)},s.src=n}),fe=(n,t,e)=>{const s=-n/2,r=-t/2;for(let a=0;a<Math.ceil(t/10);a++)for(let c=0;c<Math.ceil(n/10);c++)e.fillStyle=(c+a)%2===0?"#FF00DC":"#000000",e.fillRect(s+c*10,r+a*10,10,10)},ge=n=>{const{src:t,onLoad:e,onLoadError:o,...s}=n,{width:r,height:a,at:c,rotation:l}=s;return async i=>{const{image:u,error:d}=await de(t,{onLoad:e,onLoadError:o});O(s)(i),i.save();const h=c.x+r/2,f=c.y+a/2;i.translate(h,f),l&&i.rotate(l),d&&fe(r,a,i),u&&i.drawImage(u,-r/2,-a/2,r,a),i.restore()}},pe=n=>{if(n.width<0||n.height<0)throw new Error("width and height must be positive");const t=ht(n),e=H(k(t),t.textArea),o=ge(t),{shapeHitbox:s,efficientHitbox:r,getBoundingBox:a}=W(t);return B({name:"image",draw:async i=>{await o(i),e==null||e.drawTextArea(i)},drawShape:o,hitbox:i=>(e==null?void 0:e.textHitbox(i))||s(i),shapeHitbox:s,efficientHitbox:r,getBoundingBox:a,...e})},xe=n=>t=>{const{type:e,fillColor:o,brushWeight:s,points:r}=n;(e==="draw"?()=>{if(r.length===1){I({at:r[0],radius:s/2,fillColor:o}).draw(t);return}t.strokeStyle=o,t.lineCap="round",t.lineJoin="round",t.lineWidth=s,t.beginPath();const[l,...i]=r;t.moveTo(l.x,l.y),i.forEach(({x:u,y:d})=>t.lineTo(u,d)),t.stroke()}:()=>{t.globalCompositeOperation="destination-out",t.lineWidth=J;for(let l=0;l<r.length-1;l++){const i=r[l],u=r[l+1],d=Math.pow(u.x-i.x,2)+Math.pow(u.y-i.y,2),h=Math.sqrt(d),f=Math.ceil(h/J);for(let p=0;p<=f;p++){const g=i.x+p/f*(u.x-i.x),m=i.y+p/f*(u.y-i.y);t.beginPath(),t.arc(g,m,J,0,Math.PI*2),t.fill()}}t.globalCompositeOperation="source-over"})(),t.lineCap="butt",t.lineJoin="miter"},me=n=>t=>{const{type:e,points:o,brushWeight:s}=n;if(e==="erase")return!1;const{at:r,width:a,height:c}=Z(n)(),{hitbox:l}=W({at:r,width:Math.max(a,s),height:Math.max(c,s)});if(!l(t))return!1;if(o.length===1){const{hitbox:i}=I({at:o[0],radius:s});if(i(t))return!0}for(let i=0;i<o.length-1;i++){const u={start:o[i],end:o[i+1]},{efficientHitbox:d}=R(u);if(d({at:t,width:1,height:1}))return!0}return!1},Z=n=>()=>{const{points:t,brushWeight:e}=n;let o=t[0].x,s=t[0].y,r=t[0].x,a=t[0].y;for(const c of t)c.x<o&&(o=c.x),c.y<s&&(s=c.y),c.x>r&&(r=c.x),c.y>a&&(a=c.y);return E({at:{x:o-e/2,y:s-e/2},width:r-o+e,height:a-s+e})},ye=n=>t=>{if(n.type==="erase")return!1;const{at:e,width:o,height:s}=Z(n)(),{points:r,brushWeight:a}=n,{efficientHitbox:c}=W({at:e,width:Math.max(o,a),height:Math.max(s,a)});if(r.length===1){const{efficientHitbox:l}=I({at:r[0],radius:a});return l(t)}if(!c(t))return!1;for(let l=0;l<r.length-1;l++){const i={start:r[l],end:r[l+1]},{efficientHitbox:u}=R(i);if(u(t))return!0}return!1},J=50,be=n=>{if(n.points.length<1)throw new Error("not enough points to draw scribble");if(n.brushWeight&&n.brushWeight<1)throw new Error('brushWeight must be at least "1"');const t=dt(n),e=Z(t),o=k(e()),s=H(o,t.textArea),r=me(t),a=ye(t),c=u=>(s==null?void 0:s.textHitbox(u))||r(u),l=xe(t);return B({name:"scribble",drawShape:l,draw:u=>{l(u),s==null||s.drawTextArea(u)},hitbox:c,shapeHitbox:r,efficientHitbox:a,getBoundingBox:e,...s})},we=n=>({...W({...ft,...n,width:n.size,height:n.size}),name:"square"}),Se=n=>{const{at:t,fillColor:e,innerRadius:o,outerRadius:s,rotation:r,points:a}=n;return c=>{c.save(),c.beginPath(),c.translate(t.x,t.y),c.rotate(r);for(let l=0;l<a*2;l++){const i=l%2===0?s:o,u=l*Math.PI/a,d=Math.cos(u)*i,h=Math.sin(u)*i;l===0?c.moveTo(d,h):c.lineTo(d,h)}c.closePath(),c.fillStyle=e,c.fill(),c.restore()}},ve=n=>{const{at:t,innerRadius:e,outerRadius:o,points:s=5,rotation:r=0}=n,a=[];for(let c=0;c<s*2;c++){const l=c%2===0?o:e,i=c*Math.PI/s,u=Math.cos(i)*l,d=Math.sin(i)*l,h=S({x:u,y:d},{x:0,y:0},r);a.push({x:h.x+t.x,y:h.y+t.y})}return a},Ae=(n,t)=>{let e=!1;for(let o=0,s=t.length-1;o<t.length;s=o++){const r=t[o].x,a=t[o].y,c=t[s].x,l=t[s].y;a>n.y!=l>n.y&&(l-a!==0?n.x<(c-r)*(n.y-a)/(l-a)+r:n.x<r)&&(e=!e)}return e},Ce=n=>t=>{const e=ve(n);return Ae(t,e)},wt=n=>()=>{const{at:t,outerRadius:e}=n,o=e*2;return E({at:{x:t.x-e,y:t.y-e},width:o,height:o})},Me=n=>t=>L(wt(n)(),t),Te=n=>{const t=gt(n);t.points<3&&console.warn("star must have at least 3 points"),t.innerRadius>=t.outerRadius&&console.warn("inner radius must be less than outer radius"),(t.innerRadius<0||t.outerRadius<0)&&console.warn("radius values must be positive");const e=H(t.at,t.textArea),o=Se(t),s=i=>{o(i),e==null||e.drawTextArea(i)},r=Ce(t),a=i=>(e==null?void 0:e.textHitbox(i))||r(i),c=Me(t),l=wt(t);return B({name:"star",draw:s,drawShape:o,hitbox:a,shapeHitbox:r,efficientHitbox:c,getBoundingBox:l,...e})},Ee=n=>{const{spacing:t,at:e,upDistance:o,downDistance:s,rotation:r,lineWidth:a,fillColor:c,fillGradient:l}=n,i=S({x:e.x,y:e.y-t},e,r),u=S({x:e.x+o,y:e.y-t},e,r),d=S({x:e.x+o,y:e.y+t},e,r),h=S({x:e.x+o-s,y:e.y+t},e,r),f=S({x:e.x+o,y:e.y},e,r);let p=[],g=[],m=[];if(l&&l.length>=2){const x=o+s+Math.PI*t,A=ot(l,o/x),C=ot(l,(x-s)/x);p=[...l.filter(b=>b.offset<=o/x),{offset:1,color:A}],g=[{offset:0,color:A},...l.filter(b=>b.offset>=o/x&&b.offset<=(x-s)/x).map(b=>({offset:(b.offset-o/x)/(Math.PI*t/x),color:b.color})),{offset:1,color:C}],m=[{offset:0,color:C},...l.filter(b=>b.offset>=(x-s)/x).map(b=>({offset:(b.offset-(x-s)/x)/(s/x),color:b.color}))]}const{drawShape:w}=R({start:i,end:u,lineWidth:a,fillColor:c,fillGradient:p}),{drawShape:y}=Q({start:d,end:h,lineWidth:a,fillColor:c,fillGradient:m});return x=>{if(w(x),y(x),x.beginPath(),x.strokeStyle=c,g.length>=2){const A=Math.PI/2+r+.01,C=-Math.PI/2+r-.01,b=f.x+Math.cos(A)*t,G=f.y+Math.sin(A)*t,Ct=f.x+Math.cos(C)*t,Mt=f.y+Math.sin(C)*t,tt=x.createLinearGradient(Ct,Mt,b,G);for(const et of g)tt.addColorStop(et.offset,et.color);x.strokeStyle=tt}x.arc(f.x,f.y,t,Math.PI/2+r+.01,-Math.PI/2+r-.01,!0),x.lineWidth=a,x.stroke(),x.closePath()}},He=n=>{const{spacing:t,at:e,downDistance:o,upDistance:s,lineWidth:r,rotation:a}=n,c=S({x:e.x,y:e.y-t},e,a),l=S({x:e.x+s,y:e.y-t},e,a),i=S({x:e.x+s,y:e.y+t},e,a),u=S({x:e.x+s-o,y:e.y+t},e,a),d=S({x:e.x+s,y:e.y},e,a),{hitbox:h}=R({start:c,end:l,lineWidth:r}),{hitbox:f}=Q({start:i,end:u,lineWidth:r}),{hitbox:p}=I({at:d,radius:t+r/2});return g=>h(g)||f(g)||p(g)},St=n=>()=>{const{spacing:t,at:e,upDistance:o,rotation:s,lineWidth:r}=n,a=S({x:e.x+o,y:e.y},e,s),c=Math.min(e.x,a.x)-r/2-t,l=Math.min(e.y,a.y)-r/2-t,i=Math.max(e.x,a.x)+r/2+t,u=Math.max(e.y,a.y)+r/2+t;return E({at:{x:c,y:l},width:i-c,height:u-l})},Be=n=>t=>L(St(n)(),t),Re=n=>{if(!n.textArea)return;const{at:t,upDistance:e,rotation:o,spacing:s,lineWidth:r}=n,a=S({x:t.x+e+s+r/2,y:t.y},t,o);return{x:a.x+Math.cos(o)*15,y:a.y+Math.sin(o)*15}},De=n=>{if(n.downDistance<0)throw new Error("downDistance must be positive");if(n.upDistance<0)throw new Error("upDistance must be positive");const t=xt(n),e=Re(t),o=H(e,t.textArea),s=St(t),r=u=>(o==null?void 0:o.textHitbox(u))||a(u),a=He(t),c=Be(t),l=Ee(t);return B({name:"uturn",draw:u=>{l(u),o==null||o.drawTextArea(u)},drawShape:l,hitbox:r,shapeHitbox:a,efficientHitbox:c,getBoundingBox:s,...o})},v={arrow:Q,circle:I,cross:he,ellipse:Pt,image:pe,line:R,rect:W,scribble:be,square:we,star:Te,triangle:Y,uturn:De},Le=n=>Object.prototype.toString.call(n)==="[object Object]",vt=(n,t)=>{const e={};if(!n)return t;if(!t)return null;const o=Object.keys(n),s=Object.keys(t);for(const r of s)o.includes(r)||(e[r]=t[r]);for(const r of o){if(Le(n[r])){const a=vt(n[r],t[r]);a&&(e[r]=a);continue}if(Array.isArray(n[r])){JSON.stringify(n[r])!==JSON.stringify(t[r])&&(e[r]=t[r]);continue}else n[r]!==t[r]&&(e[r]=t[r])}return Object.keys(e).length?e:null},Pe=500,We=new Set(["at","start","end","lineWidth","radius","fillColor"]),st=n=>JSON.parse(JSON.stringify(n)),Ie=(n,t)=>{let e=[],o=!1;const s=new Map,r=new Map,a=(c,l,i,u,d)=>{const h=`${u}-${i}`,f=r.get(h);f&&f();const{play:p,stop:g}=n({forShapes:[d],durationMs:Pe,easing:{[i]:"in-out"},keyframes:[{progress:0,properties:{[i]:c}},{progress:1,properties:{[i]:l}}]});p({shapeId:u,runCount:1}),r.set(h,()=>g({shapeId:u}))};return{captureSchemaState:(c,l)=>{o&&e.push(st({...c,shapeName:l}))},snapshotMap:s,captureFrame:c=>{const l=()=>(e=[],o=!0,c(),o=!1,e),i=l();for(const u of i){const d=t(u.id);s.set(u.id,st(d??u))}return()=>{const u=l();if(i.length!==u.length)throw new Error("tracked shape mismatch when capturing animation frame");for(let d=0;d<u.length;d++){const h=i[d],f=u[d],p=vt(h,f);if(!p)continue;if(p.id)throw new Error("id mismatch in before and after schema!");if(p.shapeName)throw new Error("shape name mismatch in before and after schema!");const g=Object.keys(p);for(const m of g){if(!We.has(m))continue;const y=s.get(f.id);if(!y||(y==null?void 0:y[m])===void 0)throw new Error(`live shape in target map missing required prop ${m}!`);a(y[m],f[m],m,f.id,f.shapeName)}}s.clear()}}}},_e=()=>Math.random().toString(36).substring(2,9),Oe={linear:n=>n,in:n=>n*n,out:n=>n*(2-n),"in-out":n=>n<.5?2*n*n:-1+(4-2*n)*n},$=n=>typeof n=="function"?n:Oe[n],Fe=n=>At(D(n)),At=n=>n.isValid(),F=(n,t,e)=>o=>{if(n.length===0)return e;if(!n.map(r=>D(r.value)).every(At))throw new Error("Invalid color provided in keyframe.");for(let r=0;r<n.length-1;r++){const a=n[r],c=n[r+1];if(o>=a.progress&&o<=c.progress){const l=c.progress-a.progress,i=(o-a.progress)/l,d=(a.easing??t)(i),h=D(a.value).toRgb(),f=D(c.value).toRgb(),p=h.r+(f.r-h.r)*d,g=h.g+(f.g-h.g)*d,m=h.b+(f.b-h.b)*d,w=h.a+(f.a-h.a)*d;return D({r:p,g,b:m,a:w}).toRgbString()}}return e},z=(n,t,e)=>o=>{if(n.length===0)return e;if(o<=n[0].progress)return n[0].value;if(o>=n[n.length-1].progress)return n[n.length-1].value;for(let s=0;s<n.length-1;s++){const r=n[s],a=n[s+1];if(o>=r.progress&&o<=a.progress){const c=(o-r.progress)/(a.progress-r.progress),l=r.easing??t;return r.value+l(c)*(a.value-r.value)}}return e},Ue=(n,t,e)=>o=>{const s=n.map(l=>({value:l.value.x,progress:l.progress})),r=n.map(l=>({value:l.value.y,progress:l.progress})),a=z(s,t,e.x),c=z(r,t,e.y);return{x:a(o),y:c(o)}},ze=(n,t,e)=>o=>{const s=n.map(f=>({...f,value:f.value.color})),r=n.map(f=>({...f,value:f.value.activeColor})),a=n.map(f=>({...f,value:f.value.textBlock.color})),c=n.map(f=>({...f,value:f.value.textBlock.fontSize})),l=F(s,t,e.color),i=F(a,t,e.textBlock.color),u=z(c,t,e.textBlock.fontSize),d=F(r,t,e.activeColor),{textBlock:h}=e;return{textBlock:{...h,color:i(o),fontSize:u(o)},color:l(o),activeColor:d(o)}},U=n=>!!n&&typeof n=="object"&&Object.getPrototypeOf(n)===Object.prototype,Ne=(...n)=>n.reduce((t,e)=>e==null?t:U(e)?(Object.keys(e).forEach(o=>{U(e[o])&&U(t[o])?t[o]=Ne(t[o],e[o]):t[o]=e[o]}),t):e,{}),Xe=new Set(["textArea"]),Ye=new Set(["at","start","end"]),Ge={progress:0,value:n=>n},qe={progress:1,value:n=>n},Ke="linear",Je=n=>{if(!U(n))return!1;const e="value"in n,o="easing"in n,s=Object.keys(n).length;return e&&s===(o?2:1)},$e=n=>{const t={durationMs:n.durationMs,delayMs:(n==null?void 0:n.delayMs)??0,properties:{},validShapes:new Set(n.forShapes)},e=[...new Set(n.keyframes.map(i=>Object.keys(i.properties)).flat())],o=e.reduce((i,u)=>{var h,f;const d=n.keyframes.map(p=>{const g=p.properties[u],m=Je(g),w=m?g.value:g,y=m?g==null?void 0:g.easing:void 0;return{progress:p.progress,value:w,easing:y!==void 0?$(y):y}}).filter(({value:p})=>p!==void 0);return((h=d.at(0))==null?void 0:h.progress)!==0&&d.unshift(Ge),((f=d.at(-1))==null?void 0:f.progress)!==1&&d.push(qe),i[u]=d,i},{}),s=i=>{var d;const u=((d=n.easing)==null?void 0:d[i])??Ke;return $(u)},r=(i,u)=>Ye.has(u),a=(i,u)=>Xe.has(u),c=[{predicate:i=>typeof i=="number",fn:z},{predicate:i=>typeof i=="string"&&Fe(i),fn:F},{predicate:r,fn:Ue},{predicate:a,fn:ze}];for(const i of e)t.properties[i]=(u,d)=>{const h=u[i];if(h===void 0)return;const f=c.find(({predicate:g})=>g(h,i));if(!f)throw`cannot interpolate value: ${JSON.stringify(h)}`;const p=o[i].map(g=>{const w=typeof g.value=="function"?g.value(h,u):g.value;if(w===void 0)throw"keyframe value cannot be undefined!";return{...g,value:a(h,i)?Wt(w).textArea:w}});return f.fn(p,s(i),h)(d)};const{customInterpolations:l}=n;if(l){const i=Object.entries(l);for(const[u,d]of i){if(!d)throw"custom path received with no options. this should never happen!";const{easing:h,value:f}=d,p=h??s(u);t.properties[u]=(g,m)=>f($(p)(m))}}return t},Ve=n=>{const t=new Map;return{timelineIdToTimeline:t,defineTimeline:o=>{const s=_e(),r=$e(o);return t.set(s,r),{play:a=>n.play({...a,timelineId:s}),pause:a=>n.pause({...a,timelineId:s}),resume:a=>n.resume({...a,timelineId:s}),stop:a=>n.stop({...a,timelineId:s}),dispose:()=>t.delete(s)}}}},ke=({durationMs:n,startedAt:t,delayMs:e})=>{const o=Date.now()-t;return o<e?0:(o-e)/n},je=({durationMs:n,startedAt:t,delayMs:e})=>{const o=Date.now()-t;return o<e?0:(o-e)%n/n},en=()=>{const n=new Map,t=new Map,{defineTimeline:e,timelineIdToTimeline:o}=Ve({play:({shapeId:c,timelineId:l,runCount:i=1/0})=>{const u={runCount:i,startedAt:Date.now(),timelineId:l},d=n.get(c);d?d.push(u):n.set(c,[u])},stop:({shapeId:c,timelineId:l})=>{const i=n.get(c);if(!i)return;const u=i.filter(d=>d.timelineId!==l);if(u.length===0)return n.delete(c);n.set(c,u)},pause:()=>console.warn("not implemented"),resume:()=>console.warn("not implemented")}),s=c=>{const l=n.get(c);if(!l||l.length===0)return;let i=l[0].schema;if(!i){console.warn("animation set without a schema. this should never happen!");return}for(const u of l){const d=o.get(u.timelineId);if(!d)throw new Error("animation activated without a timeline!");const h={...d,...u},f=t.get(c);if(!f){console.warn("animation set without shape name mapping. this should never happen!");continue}if(!h.validShapes.has(f)){console.warn("invalid shape name!");continue}if(ke(h)>=h.runCount){n.delete(c);continue}const{properties:m}=h,w=je(h),y=Object.entries(m).reduce((x,A)=>{const[C,b]=A;return x[C]=b(i,w),x},{});i={...i,...y}}return i},r=Ie(e,s),a=(c,l)=>i=>new Proxy(c(i),{get:(u,d)=>{var x;const h=d;if(!jt.has(h))return u[h];const f=n.get(i.id),p=q==null?void 0:q[l];if(!p)throw new Error(`cant find defaults for ${l}`);const g=p(i);r.captureSchemaState(g,l);const m=r.snapshotMap.get(i.id);if(m)return c(m)[h];if(!f||f.length===0)return u[h];if((x=f[0])!=null&&x.schema||(f[0].schema=g),h==="startTextAreaEdit")return console.warn("shapes with active animations cannot spawn text inputs");t.get(i.id)||t.set(i.id,l);const y=s(i.id);return y?c(y)[h]:u[h]}});return{shapes:{arrow:a(v.arrow,"arrow"),circle:a(v.circle,"circle"),cross:a(v.cross,"cross"),ellipse:a(v.ellipse,"ellipse"),image:a(v.image,"image"),line:a(v.line,"line"),rect:a(v.rect,"rect"),scribble:a(v.scribble,"scribble"),square:a(v.square,"square"),star:a(v.star,"star"),triangle:a(v.triangle,"triangle"),uturn:a(v.uturn,"uturn")},defineTimeline:e,autoAnimate:{captureFrame:r.captureFrame},getAnimatedSchema:s,activeAnimations:n}},Qe=()=>{const{class:n}=It();return T(()=>{if(!n)return[];if(typeof n!="string")throw new Error("class attribute must be a string");return n.split(" ")})},nn=_t({__name:"Button",props:{color:{},textColor:{},disabled:{type:Boolean}},setup(n){const t=n,e=T(()=>{if(!t.color)return;const h=D(t.color);if(!h.isValid())throw new Error("invalid color provided to button");return h}),o=T(()=>{if(!e.value)return;const h=e.value.isDark(),f=e.value.clone();return h?f.lighten(10):f.darken(10)}),s=T(()=>{var h,f;return d.value?(h=o.value)==null?void 0:h.toHexString():(f=e.value)==null?void 0:f.toHexString()}),r=Qe(),a=["px-2","py-1","bg-gray-800","text-gray-200","dark:bg-gray-200","dark:text-gray-800","hover:bg-gray-700","dark:hover:bg-gray-300","rounded-md","cursor-pointer","font-bold","transition","duration-100","select-none","flex","justify-center","items-center","text-center"],c=T(()=>Yt(a,r.value)),l=T(()=>t.disabled),i=T(()=>{if(t.textColor)return t.textColor;if(e.value)return e.value.isDark()?"white":"black"}),u=T(()=>{const h={pointerEvents:"none",opacity:.5,cursor:"not-allowed"},f={backgroundColor:s.value,color:i.value};return{...t.color?f:{},...l.value?h:{}}}),d=Ot(!1);return(h,f)=>(Xt(),Ft("button",{onMouseenter:f[0]||(f[0]=p=>d.value=!0),onMouseleave:f[1]||(f[1]=p=>d.value=!1),class:zt(c.value),style:Ut(u.value)},[Nt(h.$slots,"default")],38))}});export{Pe as A,nn as _,vt as a,Qe as b,he as c,Ne as d,_e as g,en as u};
