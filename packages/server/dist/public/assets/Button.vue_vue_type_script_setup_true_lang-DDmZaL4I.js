import{br as L,bs as rt,bt as nt,ba as E,bu as _,bv as M,bw as Tt,bx as V,by as P,bz as N,bA as H,bB as B,E as D,bC as Et,bD as Ht,bE as Bt,bF as Rt,bG as Dt,bH as O,bI as Lt,bJ as k,bK as X,bL as Pt,bM as W,bN as S,bO as ot,f as I,bP as Wt,b0 as It,I as T,d as _t,h as Ot,c as Ft,K as Ut,al as zt,O as Nt,o as Xt}from"./index-EG8pfFaR.js";import{t as Yt}from"./index-DGfQ7BLa.js";const Gt=n=>{const{at:t,size:e,lineWidth:o,borderRadius:s,...r}=n,a=o/2,[c,l,i,u]=rt(s),d=nt({...r,at:{x:t.x-e/2,y:t.y-a},width:e,height:o,borderRadius:[u,l,l,u]}),h=nt({...r,at:{x:t.x-a,y:t.y-e/2},width:o,height:e,borderRadius:[c,c,i,i]});return f=>d(f)||h(f)},it=n=>()=>{const{at:t,size:e}=n;return E({at:{x:t.x-e/2,y:t.y-e/2},width:e,height:e})},qt=n=>t=>L(it(n)(),t),Kt=n=>{const{at:t,size:e,rotation:o,fillColor:s,lineWidth:r,borderRadius:a}=n,c=r/2,[l,i,u,d]=rt(a);return h=>{h.save(),h.translate(t.x,t.y),h.rotate(o),_({at:{x:-c,y:-e/2},width:r,height:e/2-c,fillColor:s,borderRadius:[l,l,0,0]})(h),_({at:{x:-e/2,y:-c},width:e,height:r,fillColor:s,borderRadius:[d,i,i,d]})(h),_({at:{x:-c,y:c},width:r,height:e/2-c,fillColor:s,borderRadius:[0,0,u,u]})(h),h.restore()}},$t={...N,...P,...V,...Tt},at=M($t),Jt=n=>{if(n.lineWidth&&n.lineWidth<0)throw new Error("lineWidth must be positive");const t=at(n),e=H(t.at,t.textArea),o=Kt(t),s=i=>{o(i),e==null||e.drawTextArea(i)},r=Gt(t),a=qt(t),c=i=>(e==null?void 0:e.textHitbox(i))||r(i),l=it(t);return B({name:"cross",draw:s,drawShape:o,hitbox:c,shapeHitbox:r,efficientHitbox:a,getBoundingBox:l,...e})},Vt=new Set(["drawTextAreaMatte","drawText","drawTextArea","textHitbox","startTextAreaEdit","name","draw","drawShape","hitbox","shapeHitbox","efficientHitbox","getBoundingBox","getCenterPoint"]),kt=({durationMs:n,startedAt:t,delayMs:e})=>{const o=Date.now()-t;return o<e?0:(o-e)/n},jt=({durationMs:n,startedAt:t,delayMs:e})=>{const o=Date.now()-t;return o<e?0:(o-e)%n/n},Qt=()=>Math.random().toString(36).substring(2,9),Zt={linear:n=>n,in:n=>n*n,out:n=>n*(2-n),"in-out":n=>n<.5?2*n*n:-1+(4-2*n)*n},q=n=>typeof n=="function"?n:Zt[n],F=n=>!!n&&typeof n=="object"&&Object.getPrototypeOf(n)===Object.prototype,te=(...n)=>n.reduce((t,e)=>e==null?t:F(e)?(Object.keys(e).forEach(o=>{F(e[o])&&F(t[o])?t[o]=te(t[o],e[o]):t[o]=e[o]}),t):e,{}),z=(n,t,e)=>o=>{if(n.length===0)return e;if(o<=n[0].progress)return n[0].value;if(o>=n[n.length-1].progress)return n[n.length-1].value;for(let s=0;s<n.length-1;s++){const r=n[s],a=n[s+1];if(o>=r.progress&&o<=a.progress){const c=(o-r.progress)/(a.progress-r.progress),l=r.easing??t;return r.value+l(c)*(a.value-r.value)}}return e},ee=(n,t,e)=>o=>{const s=n.map(l=>({value:l.value.x,progress:l.progress})),r=n.map(l=>({value:l.value.y,progress:l.progress})),a=z(s,t,e.x),c=z(r,t,e.y);return{x:a(o),y:c(o)}},ne=n=>ct(D(n)),ct=n=>n.isValid(),U=(n,t,e)=>o=>{if(n.length===0)return e;if(!n.map(r=>D(r.value)).every(ct))throw new Error("Invalid color provided in keyframe.");for(let r=0;r<n.length-1;r++){const a=n[r],c=n[r+1];if(o>=a.progress&&o<=c.progress){const l=c.progress-a.progress,i=(o-a.progress)/l,d=(a.easing??t)(i),h=D(a.value).toRgb(),f=D(c.value).toRgb(),p=h.r+(f.r-h.r)*d,g=h.g+(f.g-h.g)*d,m=h.b+(f.b-h.b)*d,w=h.a+(f.a-h.a)*d;return D({r:p,g,b:m,a:w}).toRgbString()}}return e},oe=(n,t,e)=>o=>{const s=n.map(f=>({...f,value:f.value.color})),r=n.map(f=>({...f,value:f.value.activeColor})),a=n.map(f=>({...f,value:f.value.textBlock.color})),c=n.map(f=>({...f,value:f.value.textBlock.fontSize})),l=U(s,t,e.color),i=U(a,t,e.textBlock.color),u=z(c,t,e.textBlock.fontSize),d=U(r,t,e.activeColor),{textBlock:h}=e;return{textBlock:{...h,color:i(o),fontSize:u(o)},color:l(o),activeColor:d(o)}},se=new Set(["textArea"]),re=new Set(["at","start","end"]),ie={progress:0,value:n=>n},ae={progress:1,value:n=>n},ce="linear",le=n=>{if(!F(n))return!1;const e="value"in n,o="easing"in n,s=Object.keys(n).length;return e&&s===(o?2:1)},ue=n=>{const t={durationMs:n.durationMs,delayMs:(n==null?void 0:n.delayMs)??0,properties:{},validShapes:new Set(n.forShapes)},e=[...new Set(n.keyframes.map(i=>Object.keys(i.properties)).flat())],o=e.reduce((i,u)=>{var h,f;const d=n.keyframes.map(p=>{const g=p.properties[u],m=le(g),w=m?g.value:g,y=m?g==null?void 0:g.easing:void 0;return{progress:p.progress,value:w,easing:y!==void 0?q(y):y}}).filter(({value:p})=>p!==void 0);return((h=d.at(0))==null?void 0:h.progress)!==0&&d.unshift(ie),((f=d.at(-1))==null?void 0:f.progress)!==1&&d.push(ae),i[u]=d,i},{}),s=i=>{var d;const u=((d=n.easing)==null?void 0:d[i])??ce;return q(u)},r=(i,u)=>re.has(u),a=(i,u)=>se.has(u),c=[{predicate:i=>typeof i=="number",fn:z},{predicate:i=>typeof i=="string"&&ne(i),fn:U},{predicate:r,fn:ee},{predicate:a,fn:oe}];for(const i of e)t.properties[i]=(u,d)=>{const h=u[i];if(h===void 0)return;const f=c.find(({predicate:g})=>g(h,i));if(!f)throw`cannot interpolate value: ${JSON.stringify(h)}`;const p=o[i].map(g=>{const w=typeof g.value=="function"?g.value(h,u):g.value;if(w===void 0)throw"keyframe value cannot be undefined!";return{...g,value:a(h,i)?Et(w).textArea:w}});return f.fn(p,s(i),h)(d)};const{customInterpolations:l}=n;if(l){const i=Object.entries(l);for(const[u,d]of i){if(!d)throw"custom path received with no options. this should never happen!";const{easing:h,value:f}=d,p=h??s(u);t.properties[u]=(g,m)=>f(q(p)(m))}}return t},he=n=>{const t=new Map;return{timelineIdToTimeline:t,defineTimeline:o=>{const s=Qt(),r=ue(o);return t.set(s,r),{play:a=>n.play({...a,timelineId:s}),pause:a=>n.pause({...a,timelineId:s}),resume:a=>n.resume({...a,timelineId:s}),stop:a=>n.stop({...a,timelineId:s}),dispose:()=>t.delete(s)}}}},de={...P,...N,...V},lt=M(de),ut={...V,...P,textOffsetFromCenter:0},ht=M(ut),dt={...ut},ft=M(dt),gt={...Ht},fe=M(gt),ge={...N},pt=M(ge),pe={...P,brushWeight:3},xt=M(pe),xe={...P,...N,points:5},mt=M(xe),me={...P},yt=M(me),K={arrow:ft,circle:Dt,cross:at,ellipse:Rt,image:pt,line:ht,rect:Bt,scribble:xt,square:fe,star:mt,triangle:yt,uturn:lt},ye=n=>t=>{const{start:e,end:o,lineWidth:s,fillColor:r,dash:a=[],fillGradient:c}=n;if(s!==0){if(t.save(),t.beginPath(),t.moveTo(e.x,e.y),t.lineTo(o.x,o.y),t.lineWidth=s,t.strokeStyle=r,c&&c.length>=2){const l=t.createLinearGradient(e.x,e.y,o.x,o.y);c.forEach(({offset:i,color:u})=>{l.addColorStop(i,u)}),t.strokeStyle=l}t.setLineDash(a),t.stroke(),t.closePath(),t.restore()}},be=n=>t=>O(n,t),j=n=>()=>{const{start:t,end:e,lineWidth:o}=n,s=Math.min(t.x,e.x)-o/2,r=Math.min(t.y,e.y)-o/2,a=Math.max(t.x,e.x)+o/2,c=Math.max(t.y,e.y)+o/2;return E({at:{x:s,y:r},width:a-s,height:c-r})},we=n=>{const{start:t,end:e,lineWidth:o}=n,s=Math.hypot(e.x-t.x,e.y-t.y),r=Math.atan2(e.y-t.y,e.x-t.x),a=Math.abs(Math.cos(r))+Math.abs(Math.sin(r)),c=Math.min(50,s*a),l=Math.ceil(s/c),i=(e.x-t.x)/s,u=(e.y-t.y)/s;return d=>L(j(n)(),d)?Array.from({length:l},(p,g)=>{const m=t.x+i*c*g,w=t.y+u*c*g,y=m+i*c,x=w+u*c,A=Math.min(m,y)-o/2,C=Math.min(w,x)-o/2,b=Math.abs(y-m)+o,G=Math.abs(x-w)+o;return E({at:{x:A,y:C},width:b,height:G})}).some(p=>L(p,d)):!1},bt=n=>{if(!n.textArea)return;const{textOffsetFromCenter:t,start:e,end:o}=n,s=Lt(e,o),r=t*Math.cos(s),a=t*Math.sin(s),c=(e.x+o.x)/2+r,l=(e.y+o.y)/2+a;return{x:c,y:l}},R=n=>{if(n.lineWidth&&n.lineWidth<0)throw new Error("lineWidth must be positive");const t=ht(n),e=bt(t),o=H(e,t.textArea),s=be(t),r=we(t),a=u=>(o==null?void 0:o.textHitbox(u))||s(u),c=j(t),l=ye(t);return B({name:"line",draw:u=>{l(u),o==null||o.drawTextArea(u)},drawShape:l,hitbox:a,shapeHitbox:s,efficientHitbox:r,getBoundingBox:c,...o})},Se=n=>t=>{const{pointA:e,pointB:o,pointC:s,stroke:r}=n,{x:a,y:c}=t,l=.5*(-o.y*s.x+e.y*(-o.x+s.x)+e.x*(o.y-s.y)+o.x*s.y),i=1/(2*l)*(e.y*s.x-e.x*s.y+(s.y-e.y)*a+(e.x-s.x)*c),u=1/(2*l)*(e.x*o.y-e.y*o.x+(e.y-o.y)*a+(o.x-e.x)*c),d=i>0&&u>0&&1-i-u>0;if(!r)return d;const h={start:e,end:o,...r},f={start:o,end:s,...r},p={start:s,end:e,...r},g=O(h,t)||O(f,t)||O(p,t);return d||g},wt=n=>()=>{const{pointA:t,pointB:e,pointC:o}=n,s=Math.min(t.x,e.x,o.x),r=Math.min(t.y,e.y,o.y),a=Math.max(t.x,e.x,o.x),c=Math.max(t.y,e.y,o.y);return E({at:{x:s,y:r},width:a-s,height:c-r})},ve=n=>t=>L(wt(n)(),t),Ae=n=>t=>{const{pointA:e,pointB:o,pointC:s,fillColor:r,stroke:a,fillGradient:c}=n;if(t.beginPath(),t.moveTo(e.x,e.y),t.lineTo(o.x,o.y),t.lineTo(s.x,s.y),c&&c.length>=2){const l={x:(o.x+s.x)/2,y:(o.y+s.y)/2},i=t.createLinearGradient(l.x,l.y,e.x,e.y);c.forEach(({offset:u,color:d})=>{i.addColorStop(u,d)}),t.fillStyle=i}else t.fillStyle=r;t.fill(),t.closePath(),a&&(t.lineWidth=a.lineWidth,t.strokeStyle=a.color,t.setLineDash(a.dash??[]),t.stroke(),t.setLineDash([]))},Y=n=>{const t=yt(n),e=wt(t),o=k(e()),s=H(o,t.textArea),r=Se(t),a=ve(t),c=u=>(s==null?void 0:s.textHitbox(u))||r(u),l=Ae(t);return B({name:"triangle",draw:u=>{l(u),s==null||s.drawTextArea(u)},drawShape:l,hitbox:c,shapeHitbox:r,efficientHitbox:a,getBoundingBox:e,...s})},Ce=n=>{var d;const{start:t,end:e,lineWidth:o,fillGradient:s,fillColor:r}=n,a=X({start:t,end:e,lineWidth:o}),{arrowHeadHeight:c}=Pt(o),l=Math.atan2(e.y-t.y,e.x-t.x),i=R({...n,end:{x:e.x-c*Math.cos(l)+Math.cos(l),y:e.y-c*Math.sin(l)+Math.sin(l)}}),u=Y({...a,fillColor:s&&s.length?(d=s.at(-1))==null?void 0:d.color:r});return h=>{i.drawShape(h),u.drawShape(h)}},Me=n=>{const{start:t,end:e,lineWidth:o}=n,s=X({start:t,end:e,lineWidth:o}),r=R(n),a=Y(s);return c=>r.hitbox(c)||a.hitbox(c)},Te=n=>()=>{const{at:t,width:e,height:o}=j(n)(),s={x:t.x,y:t.y},r={x:t.x+e,y:t.y+o},{start:a,end:c,lineWidth:l}={...dt,...n},i=X({start:a,end:c,lineWidth:l}),u=Math.min(s.x,r.x,i.pointA.x,i.pointB.x,i.pointC.x),d=Math.max(s.x,r.x,i.pointA.x,i.pointB.x,i.pointC.x),h=Math.min(s.y,r.y,i.pointA.y,i.pointB.y,i.pointC.y),f=Math.max(s.y,r.y,i.pointA.y,i.pointB.y,i.pointC.y);return E({at:{x:u,y:h},width:d-u,height:f-h})},Ee=n=>{const{start:t,end:e,lineWidth:o}=n,s=X({start:t,end:e,lineWidth:o}),r=R(n),a=Y(s);return c=>r.efficientHitbox(c)||a.efficientHitbox(c)},Q=n=>{if(n.lineWidth&&n.lineWidth<0)throw new Error("width must be positive");const t=ft(n),e=bt(t),o=H(e,t.textArea),s=Ce(t),r=Me(t),a=Ee(t),c=u=>(o==null?void 0:o.textHitbox(u))||r(u),l=Te(t);return B({name:"arrow",draw:u=>{s(u),o==null||o.drawTextArea(u)},drawShape:s,hitbox:c,shapeHitbox:r,efficientHitbox:a,getBoundingBox:l,...o})},He=n=>({...W({...gt,...n,width:n.size,height:n.size}),name:"square"}),Be=n=>{const{spacing:t,at:e,upDistance:o,downDistance:s,rotation:r,lineWidth:a,fillColor:c,fillGradient:l}=n,i=S({x:e.x,y:e.y-t},e,r),u=S({x:e.x+o,y:e.y-t},e,r),d=S({x:e.x+o,y:e.y+t},e,r),h=S({x:e.x+o-s,y:e.y+t},e,r),f=S({x:e.x+o,y:e.y},e,r);let p=[],g=[],m=[];if(l&&l.length>=2){const x=o+s+Math.PI*t,A=ot(l,o/x),C=ot(l,(x-s)/x);p=[...l.filter(b=>b.offset<=o/x),{offset:1,color:A}],g=[{offset:0,color:A},...l.filter(b=>b.offset>=o/x&&b.offset<=(x-s)/x).map(b=>({offset:(b.offset-o/x)/(Math.PI*t/x),color:b.color})),{offset:1,color:C}],m=[{offset:0,color:C},...l.filter(b=>b.offset>=(x-s)/x).map(b=>({offset:(b.offset-(x-s)/x)/(s/x),color:b.color}))]}const{drawShape:w}=R({start:i,end:u,lineWidth:a,fillColor:c,fillGradient:p}),{drawShape:y}=Q({start:d,end:h,lineWidth:a,fillColor:c,fillGradient:m});return x=>{if(w(x),y(x),x.beginPath(),x.strokeStyle=c,g.length>=2){const A=Math.PI/2+r+.01,C=-Math.PI/2+r-.01,b=f.x+Math.cos(A)*t,G=f.y+Math.sin(A)*t,Ct=f.x+Math.cos(C)*t,Mt=f.y+Math.sin(C)*t,tt=x.createLinearGradient(Ct,Mt,b,G);for(const et of g)tt.addColorStop(et.offset,et.color);x.strokeStyle=tt}x.arc(f.x,f.y,t,Math.PI/2+r+.01,-Math.PI/2+r-.01,!0),x.lineWidth=a,x.stroke(),x.closePath()}},Re=n=>{const{spacing:t,at:e,downDistance:o,upDistance:s,lineWidth:r,rotation:a}=n,c=S({x:e.x,y:e.y-t},e,a),l=S({x:e.x+s,y:e.y-t},e,a),i=S({x:e.x+s,y:e.y+t},e,a),u=S({x:e.x+s-o,y:e.y+t},e,a),d=S({x:e.x+s,y:e.y},e,a),{hitbox:h}=R({start:c,end:l,lineWidth:r}),{hitbox:f}=Q({start:i,end:u,lineWidth:r}),{hitbox:p}=I({at:d,radius:t+r/2});return g=>h(g)||f(g)||p(g)},St=n=>()=>{const{spacing:t,at:e,upDistance:o,rotation:s,lineWidth:r}=n,a=S({x:e.x+o,y:e.y},e,s),c=Math.min(e.x,a.x)-r/2-t,l=Math.min(e.y,a.y)-r/2-t,i=Math.max(e.x,a.x)+r/2+t,u=Math.max(e.y,a.y)+r/2+t;return E({at:{x:c,y:l},width:i-c,height:u-l})},De=n=>t=>L(St(n)(),t),Le=n=>{if(!n.textArea)return;const{at:t,upDistance:e,rotation:o,spacing:s,lineWidth:r}=n,a=S({x:t.x+e+s+r/2,y:t.y},t,o);return{x:a.x+Math.cos(o)*15,y:a.y+Math.sin(o)*15}},Pe=n=>{if(n.downDistance<0)throw new Error("downDistance must be positive");if(n.upDistance<0)throw new Error("upDistance must be positive");const t=lt(n),e=Le(t),o=H(e,t.textArea),s=St(t),r=u=>(o==null?void 0:o.textHitbox(u))||a(u),a=Re(t),c=De(t),l=Be(t);return B({name:"uturn",draw:u=>{l(u),o==null||o.drawTextArea(u)},drawShape:l,hitbox:r,shapeHitbox:a,efficientHitbox:c,getBoundingBox:s,...o})},We=n=>t=>{const{type:e,fillColor:o,brushWeight:s,points:r}=n;(e==="draw"?()=>{if(r.length===1){I({at:r[0],radius:s/2,fillColor:o}).draw(t);return}t.strokeStyle=o,t.lineCap="round",t.lineJoin="round",t.lineWidth=s,t.beginPath();const[l,...i]=r;t.moveTo(l.x,l.y),i.forEach(({x:u,y:d})=>t.lineTo(u,d)),t.stroke()}:()=>{t.globalCompositeOperation="destination-out",t.lineWidth=$;for(let l=0;l<r.length-1;l++){const i=r[l],u=r[l+1],d=Math.pow(u.x-i.x,2)+Math.pow(u.y-i.y,2),h=Math.sqrt(d),f=Math.ceil(h/$);for(let p=0;p<=f;p++){const g=i.x+p/f*(u.x-i.x),m=i.y+p/f*(u.y-i.y);t.beginPath(),t.arc(g,m,$,0,Math.PI*2),t.fill()}}t.globalCompositeOperation="source-over"})(),t.lineCap="butt",t.lineJoin="miter"},Ie=n=>t=>{const{type:e,points:o,brushWeight:s}=n;if(e==="erase")return!1;const{at:r,width:a,height:c}=Z(n)(),{hitbox:l}=W({at:r,width:Math.max(a,s),height:Math.max(c,s)});if(!l(t))return!1;if(o.length===1){const{hitbox:i}=I({at:o[0],radius:s});if(i(t))return!0}for(let i=0;i<o.length-1;i++){const u={start:o[i],end:o[i+1]},{efficientHitbox:d}=R(u);if(d({at:t,width:1,height:1}))return!0}return!1},Z=n=>()=>{const{points:t,brushWeight:e}=n;let o=t[0].x,s=t[0].y,r=t[0].x,a=t[0].y;for(const c of t)c.x<o&&(o=c.x),c.y<s&&(s=c.y),c.x>r&&(r=c.x),c.y>a&&(a=c.y);return E({at:{x:o-e/2,y:s-e/2},width:r-o+e,height:a-s+e})},_e=n=>t=>{if(n.type==="erase")return!1;const{at:e,width:o,height:s}=Z(n)(),{points:r,brushWeight:a}=n,{efficientHitbox:c}=W({at:e,width:Math.max(o,a),height:Math.max(s,a)});if(r.length===1){const{efficientHitbox:l}=I({at:r[0],radius:a});return l(t)}if(!c(t))return!1;for(let l=0;l<r.length-1;l++){const i={start:r[l],end:r[l+1]},{efficientHitbox:u}=R(i);if(u(t))return!0}return!1},$=50,Oe=n=>{if(n.points.length<1)throw new Error("not enough points to draw scribble");if(n.brushWeight&&n.brushWeight<1)throw new Error('brushWeight must be at least "1"');const t=xt(n),e=Z(t),o=k(e()),s=H(o,t.textArea),r=Ie(t),a=_e(t),c=u=>(s==null?void 0:s.textHitbox(u))||r(u),l=We(t);return B({name:"scribble",drawShape:l,draw:u=>{l(u),s==null||s.drawTextArea(u)},hitbox:c,shapeHitbox:r,efficientHitbox:a,getBoundingBox:e,...s})},Fe=n=>{const{at:t,innerRadius:e,outerRadius:o,points:s=5,rotation:r=0}=n,a=[];for(let c=0;c<s*2;c++){const l=c%2===0?o:e,i=c*Math.PI/s,u=Math.cos(i)*l,d=Math.sin(i)*l,h=S({x:u,y:d},{x:0,y:0},r);a.push({x:h.x+t.x,y:h.y+t.y})}return a},Ue=(n,t)=>{let e=!1;for(let o=0,s=t.length-1;o<t.length;s=o++){const r=t[o].x,a=t[o].y,c=t[s].x,l=t[s].y;a>n.y!=l>n.y&&(l-a!==0?n.x<(c-r)*(n.y-a)/(l-a)+r:n.x<r)&&(e=!e)}return e},ze=n=>t=>{const e=Fe(n);return Ue(t,e)},vt=n=>()=>{const{at:t,outerRadius:e}=n,o=e*2;return E({at:{x:t.x-e,y:t.y-e},width:o,height:o})},Ne=n=>t=>L(vt(n)(),t),Xe=n=>{const{at:t,fillColor:e,innerRadius:o,outerRadius:s,rotation:r,points:a}=n;return c=>{c.save(),c.beginPath(),c.translate(t.x,t.y),c.rotate(r);for(let l=0;l<a*2;l++){const i=l%2===0?s:o,u=l*Math.PI/a,d=Math.cos(u)*i,h=Math.sin(u)*i;l===0?c.moveTo(d,h):c.lineTo(d,h)}c.closePath(),c.fillStyle=e,c.fill(),c.restore()}},Ye=n=>{const t=mt(n);t.points<3&&console.warn("star must have at least 3 points"),t.innerRadius>=t.outerRadius&&console.warn("inner radius must be less than outer radius"),(t.innerRadius<0||t.outerRadius<0)&&console.warn("radius values must be positive");const e=H(t.at,t.textArea),o=Xe(t),s=i=>{o(i),e==null||e.drawTextArea(i)},r=ze(t),a=i=>(e==null?void 0:e.textHitbox(i))||r(i),c=Ne(t),l=vt(t);return B({name:"star",draw:s,drawShape:o,hitbox:a,shapeHitbox:r,efficientHitbox:c,getBoundingBox:l,...e})},J=new Map,Ge=async(n,t)=>new Promise(e=>{J.has(n)&&e(J.get(n));const o={image:null,loading:!0,error:!1};J.set(n,o);const s=new Image;s.onload=()=>{var r;o.image=s,o.loading=!1,(r=t.onLoad)==null||r.call(t),e(o)},s.onerror=()=>{var r;o.loading=!1,o.error=!0,(r=t.onLoadError)==null||r.call(t),e(o)},s.src=n}),qe=(n,t,e)=>{const s=-n/2,r=-t/2;for(let a=0;a<Math.ceil(t/10);a++)for(let c=0;c<Math.ceil(n/10);c++)e.fillStyle=(c+a)%2===0?"#FF00DC":"#000000",e.fillRect(s+c*10,r+a*10,10,10)},Ke=n=>{const{src:t,onLoad:e,onLoadError:o,...s}=n,{width:r,height:a,at:c,rotation:l}=s;return async i=>{const{image:u,error:d}=await Ge(t,{onLoad:e,onLoadError:o});_(s)(i),i.save();const h=c.x+r/2,f=c.y+a/2;i.translate(h,f),l&&i.rotate(l),d&&qe(r,a,i),u&&i.drawImage(u,-r/2,-a/2,r,a),i.restore()}},$e=n=>{if(n.width<0||n.height<0)throw new Error("width and height must be positive");const t=pt(n),e=H(k(t),t.textArea),o=Ke(t),{shapeHitbox:s,efficientHitbox:r,getBoundingBox:a}=W(t);return B({name:"image",draw:async i=>{await o(i),e==null||e.drawTextArea(i)},drawShape:o,hitbox:i=>(e==null?void 0:e.textHitbox(i))||s(i),shapeHitbox:s,efficientHitbox:r,getBoundingBox:a,...e})},v={arrow:Q,circle:I,cross:Jt,ellipse:Wt,image:$e,line:R,rect:W,scribble:Oe,square:He,star:Ye,triangle:Y,uturn:Pe},Je=n=>Object.prototype.toString.call(n)==="[object Object]",At=(n,t)=>{const e={};if(!n)return t;if(!t)return null;const o=Object.keys(n),s=Object.keys(t);for(const r of s)o.includes(r)||(e[r]=t[r]);for(const r of o){if(Je(n[r])){const a=At(n[r],t[r]);a&&(e[r]=a);continue}if(Array.isArray(n[r])){JSON.stringify(n[r])!==JSON.stringify(t[r])&&(e[r]=t[r]);continue}else n[r]!==t[r]&&(e[r]=t[r])}return Object.keys(e).length?e:null},Ve=500,ke=new Set(["at","start","end","lineWidth","radius","fillColor"]),st=n=>JSON.parse(JSON.stringify(n)),je=(n,t)=>{let e=[],o=!1;const s=new Map,r=new Map,a=(c,l,i,u,d)=>{const h=`${u}-${i}`,f=r.get(h);f&&f();const{play:p,stop:g}=n({forShapes:[d],durationMs:Ve,easing:{[i]:"in-out"},keyframes:[{progress:0,properties:{[i]:c}},{progress:1,properties:{[i]:l}}]});p({shapeId:u,runCount:1}),r.set(h,()=>g({shapeId:u}))};return{captureSchemaState:(c,l)=>{o&&e.push(st({...c,shapeName:l}))},snapshotMap:s,captureFrame:c=>{const l=()=>(e=[],o=!0,c(),o=!1,e),i=l();for(const u of i){const d=t(u.id);s.set(u.id,st(d??u))}return()=>{const u=l();if(i.length!==u.length)throw new Error("tracked shape mismatch when capturing animation frame");for(let d=0;d<u.length;d++){const h=i[d],f=u[d],p=At(h,f);if(!p)continue;if(p.id)throw new Error("id mismatch in before and after schema!");if(p.shapeName)throw new Error("shape name mismatch in before and after schema!");const g=Object.keys(p);for(const m of g){if(!ke.has(m))continue;const y=s.get(f.id);if(!y||(y==null?void 0:y[m])===void 0)throw new Error(`live shape in target map missing required prop ${m}!`);a(y[m],f[m],m,f.id,f.shapeName)}}s.clear()}}}},en=()=>{const n=new Map,t=new Map,{defineTimeline:e,timelineIdToTimeline:o}=he({play:({shapeId:c,timelineId:l,runCount:i=1/0})=>{const u={runCount:i,startedAt:Date.now(),timelineId:l},d=n.get(c);d?d.push(u):n.set(c,[u])},stop:({shapeId:c,timelineId:l})=>{const i=n.get(c);if(!i)return;const u=i.filter(d=>d.timelineId!==l);if(u.length===0)return n.delete(c);n.set(c,u)},pause:()=>console.warn("not implemented"),resume:()=>console.warn("not implemented")}),s=c=>{const l=n.get(c);if(!l||l.length===0)return;let i=l[0].schema;if(!i){console.warn("animation set without a schema. this should never happen!");return}for(const u of l){const d=o.get(u.timelineId);if(!d)throw new Error("animation activated without a timeline!");const h={...d,...u},f=t.get(c);if(!f){console.warn("animation set without shape name mapping. this should never happen!");continue}if(!h.validShapes.has(f)){console.warn("invalid shape name!");continue}if(kt(h)>=h.runCount){n.delete(c);continue}const{properties:m}=h,w=jt(h),y=Object.entries(m).reduce((x,A)=>{const[C,b]=A;return x[C]=b(i,w),x},{});i={...i,...y}}return i},r=je(e,s),a=(c,l)=>i=>new Proxy(c(i),{get:(u,d)=>{var x;const h=d;if(!Vt.has(h))return u[h];const f=n.get(i.id),p=K==null?void 0:K[l];if(!p)throw new Error(`cant find defaults for ${l}`);const g=p(i);r.captureSchemaState(g,l);const m=r.snapshotMap.get(i.id);if(m)return c(m)[h];if(!f||f.length===0)return u[h];(x=f[0])!=null&&x.schema||(f[0].schema=g),t.get(i.id)||t.set(i.id,l);const y=s(i.id);return y?c(y)[h]:u[h]}});return{shapes:{arrow:a(v.arrow,"arrow"),circle:a(v.circle,"circle"),cross:a(v.cross,"cross"),ellipse:a(v.ellipse,"ellipse"),image:a(v.image,"image"),line:a(v.line,"line"),rect:a(v.rect,"rect"),scribble:a(v.scribble,"scribble"),square:a(v.square,"square"),star:a(v.star,"star"),triangle:a(v.triangle,"triangle"),uturn:a(v.uturn,"uturn")},defineTimeline:e,autoAnimate:{captureFrame:r.captureFrame},getAnimatedSchema:s,activeAnimations:n}},Qe=()=>{const{class:n}=It();return T(()=>{if(!n)return[];if(typeof n!="string")throw new Error("class attribute must be a string");return n.split(" ")})},nn=_t({__name:"Button",props:{color:{},textColor:{},disabled:{type:Boolean}},setup(n){const t=n,e=T(()=>{if(!t.color)return;const h=D(t.color);if(!h.isValid())throw new Error("invalid color provided to button");return h}),o=T(()=>{if(!e.value)return;const h=e.value.isDark(),f=e.value.clone();return h?f.lighten(10):f.darken(10)}),s=T(()=>{var h,f;return d.value?(h=o.value)==null?void 0:h.toHexString():(f=e.value)==null?void 0:f.toHexString()}),r=Qe(),a=["px-2","py-1","bg-gray-800","text-gray-200","dark:bg-gray-200","dark:text-gray-800","hover:bg-gray-700","dark:hover:bg-gray-300","rounded-md","cursor-pointer","font-bold","transition","duration-100","select-none","flex","justify-center","items-center","text-center"],c=T(()=>Yt(a,r.value)),l=T(()=>t.disabled),i=T(()=>{if(t.textColor)return t.textColor;if(e.value)return e.value.isDark()?"white":"black"}),u=T(()=>{const h={pointerEvents:"none",opacity:.5,cursor:"not-allowed"},f={backgroundColor:s.value,color:i.value};return{...t.color?f:{},...l.value?h:{}}}),d=Ot(!1);return(h,f)=>(Xt(),Ft("button",{onMouseenter:f[0]||(f[0]=p=>d.value=!0),onMouseleave:f[1]||(f[1]=p=>d.value=!1),class:zt(c.value),style:Ut(u.value)},[Nt(h.$slots,"default")],38))}});export{Ve as A,nn as _,Qe as a,At as b,Jt as c,te as d,Qt as g,en as u};
