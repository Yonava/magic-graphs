import{az as Se,aA as Te,aB as Ee,U as Ne,z as J,B as V,aC as ne,a2 as xe,aD as Ae,ac as se,H as U,g as C,y as fe,aE as we,aa as Z,aF as Ce,aG as Me,ap as Ie,aq as De,aH as ke,aI as he,u as ve,A as Q,as as Be,at as Re,e as Oe,o as Fe,N as _e}from"./index-D54qcSWh.js";import{c as pe,a as Le,u as Ge,l as me,b as Pe,g as be,r as re,s as Y,_ as Ue}from"./ResponsiveCanvas.vue_vue_type_script_setup_true_lang-k-PFhbuS.js";const $={light:Se,dark:Te,girl:Ee},Ke=(r,a)=>{const e=Ne();J(e,()=>{const s=r.theme.value;e.value?Object.assign(s,{...$.dark,...a}):Object.assign(s,{...$.light,...a})},{immediate:!0})},H=r=>{const a={...r};for(const e in a)typeof a[e]=="object"&&(a[e]=H(a[e]));return a},We=(r,a)=>{const e=a("nodeColor",r),s=a("nodeBorderColor",r),t=a("nodeSize",r),n=a("nodeBorderWidth",r),y=a("nodeText",r),l=a("nodeTextSize",r),b=a("nodeTextColor",r),f=a("nodeShape",r),E=pe({at:{x:r.x,y:r.y},radius:t,color:e,stroke:{color:s,width:n},textArea:{text:{content:y,fontSize:l,fontWeight:"bold",color:b},color:V.TRANSPARENT}}),S=Le({at:{x:r.x-t,y:r.y-t},size:t*2,color:e,stroke:{color:s,width:n},textArea:{text:{content:y,fontSize:l,fontWeight:"bold",color:b},color:V.TRANSPARENT}});return{shape:f==="circle"?E:S,id:r.id,graphType:"node"}},qe=1.618,ae=2,He=(r,a)=>{const{displayEdgeLabels:e,isGraphDirected:s}=a.settings.value,[t,n]=ne(r.id,a),l=xe(t.id,n.id,a).length>1,b=n===t,f=a.getTheme("nodeBorderWidth",t),E=a.getTheme("nodeBorderWidth",n),S=a.getTheme("nodeSize",t),T=a.getTheme("nodeSize",n),v=Math.atan2(n.y-t.y,n.x-t.x),i=E/2+ae,c={x:(T+i)*Math.cos(v),y:(T+i)*Math.sin(v)},p={x:t.x,y:t.y},d={x:n.x-(s?c.x:0),y:n.y-(s?c.y:0)},g=a.getTheme("edgeWidth",r),o=g*1.2;l&&(p.x+=Math.cos(v+Math.PI/2)*o,p.y+=Math.sin(v+Math.PI/2)*o,d.x+=Math.cos(v+Math.PI/2)*o,d.y+=Math.sin(v+Math.PI/2)*o);const h=Ae(p,a.edges.value.filter(R=>(R.from===t.id||R.to===n.id)&&R.from!==R.to).map(R=>{const[G,q]=ne(R.id,a);return t.id===G.id?{x:q.x,y:q.y}:{x:G.x,y:G.y}}).filter((R,G,q)=>G===q.findIndex(j=>j.x===R.x&&j.y===R.y))),u=a.getTheme("edgeColor",r),m=a.getTheme("edgeTextColor",r),A=a.getTheme("graphBgColor"),D=a.getTheme("edgeText",r),w=a.getTheme("edgeTextSize",r),k=a.getTheme("edgeTextFontWeight",r),M=e?{color:A,activeColor:A,text:{content:D,color:m,fontSize:w,fontWeight:k}}:void 0,I=(S+f)*qe,O=I-(S+f/2)-ae;if(b)return{shape:Ge({spacing:g*1.2,at:{x:t.x,y:t.y},upDistance:I,downDistance:O,rotation:h,lineWidth:g,color:u,textArea:M}),id:r.id,graphType:"edge"};const _=S+f/2+T+E/2,L=(t.x-n.x)**2+(t.y-n.y)**2;if(_**2>L)return;if(!s)return{shape:me({start:p,end:d,width:g,color:u,textArea:M}),id:r.id,graphType:"edge"};const P=S>=50?.9:S>=25?1:1.3;return{shape:Pe({start:p,end:d,width:g,textOffsetFromCenter:S**P,color:u,textArea:M}),id:r.id,graphType:"edge"}},ze=()=>({primaryColor:[],secondaryColor:[],tertiaryColor:[],primaryTextColor:[],secondaryTextColor:[],tertiaryTextColor:[],nodeSize:[],nodeBorderWidth:[],nodeColor:[],nodeBorderColor:[],nodeFocusColor:[],nodeFocusBorderColor:[],nodeText:[],nodeFocusTextColor:[],nodeTextSize:[],nodeTextColor:[],nodeShape:[],edgeColor:[],edgeWidth:[],edgeText:[],edgeTextSize:[],edgeTextColor:[],edgeFocusTextColor:[],edgeTextFontWeight:[],edgeFocusColor:[],graphBgColor:[],graphBgPatternColor:[],nodeAnchorRadius:[],nodeAnchorColor:[],nodeAnchorColorWhenParentFocused:[],linkPreviewColor:[],linkPreviewWidth:[],marqueeSelectionBoxColor:[],marqueeSelectionBoxBorderColor:[],marqueeEncapsulatedNodeBoxColor:[],marqueeEncapsulatedNodeBoxBorderColor:[]}),Je=r=>Object.prototype.toString.call(r)==="[object Object]",ee=(r,a)=>{const e={};if(!r)return a;if(!a)return null;const s=Object.keys(r),t=Object.keys(a);for(const n of t)s.includes(n)||(e[n]=a[n]);for(const n of s){if(Je(r[n])){const y=ee(r[n],a[n]);y&&(e[n]=y);continue}if(Array.isArray(r[n])){JSON.stringify(r[n])!==JSON.stringify(a[n])&&(e[n]=a[n]);continue}else r[n]!==a[n]&&(e[n]=a[n])}return Object.keys(e).length?e:null},Ve=r=>({subscribe:(a,e)=>r[a].add(e),unsubscribe:(a,e)=>r[a].delete(e),emit:(a,...e)=>{for(const s of r[a])s(...e)}}),je=()=>({onStructureChange:new Set,onNodeAdded:new Set,onBulkNodeAdded:new Set,onNodeRemoved:new Set,onBulkNodeRemoved:new Set,onNodeMoved:new Set,onBulkNodeMoved:new Set,onEdgeAdded:new Set,onBulkEdgeAdded:new Set,onEdgeRemoved:new Set,onBulkEdgeRemoved:new Set,onEdgeLabelChange:new Set,onRepaint:new Set,onNodeHoverChange:new Set,onGraphReset:new Set,onClick:new Set,onMouseDown:new Set,onMouseUp:new Set,onMouseMove:new Set,onDblClick:new Set,onContextMenu:new Set,onKeyDown:new Set,onKeyUp:new Set,onThemeChange:new Set,onSettingsChange:new Set,onUndo:new Set,onRedo:new Set,onFocusChange:new Set,onNodeDragStart:new Set,onNodeDrop:new Set,onNodeAnchorDragStart:new Set,onNodeAnchorDrop:new Set,onGroupDragStart:new Set,onGroupDrop:new Set}),ue=r=>r==null,Ye=r=>{const a=r.trim().split("/").filter(Boolean);if(a.length!==2)return!1;const[e,s]=a.map(Number);return!(ue(e)||ue(s))},Ze=r=>{if(!Ye(r))return;const a=r.split("/"),[e,s]=a.map(Number);return e/s},Xe={displayEdgeLabels:!0,edgeLabelsEditable:!0,edgeInputToLabel:r=>{var s;const a=r.trim();if(!a)return;const e=(s=Ze(a))==null?void 0:s.toFixed(2);return e==="Infinity"?"∞":e==="-Infinity"?"-∞":e===void 0&&isNaN(Number(a))?void 0:e??a},newNodeLabelGetter:null,isGraphDirected:!0},Qe={focusable:!0,focusBlacklist:[]},$e={draggable:!0},et={nodeAnchors:!0},tt={marquee:!0,marqueeSelectableGraphTypes:["node","edge"]},ot={userEditable:!0,userAddedEdgeLabel:"1",userAddedEdgeRuleNoSelfLoops:!1,userAddedEdgeRuleOneEdgePerPath:!1},nt={persistent:!0,persistentStorageKey:"graph",persistentTrackTheme:!1,persistentTrackSettings:!1},st={},rt={...Xe,...Qe,...$e,...et,...tt,...ot,...nt,...st},at=(r,a)=>(e,...s)=>{const t=a[e].findLast(y=>{const l=y.value;return se(l,...s)!==void 0}),n=(t==null?void 0:t.value)??r.value[e];if(!n)throw new Error(`Theme property "${e}" not found`);return se(n,...s)},ut=(r,a)=>{const e=U(()=>{const t=new Map;for(const n of r.value)t.set(n.id,n);return t}),s=U(()=>{const t=new Map;for(const n of a.value)t.set(n.id,n);return t});return{nodeIdToNodeMap:e,edgeIdToEdgeMap:s}},it=({canvas:r,emit:a})=>{const e=C([]),s=[],t=()=>{var T,v,i,c;if(!r.value)return;const l=r.value.getContext("2d");if(!l)return;l.clearRect(0,0,r.value.width,r.value.height);const b=s.reduce((p,d)=>d(p),[]);e.value=[...b.sort((p,d)=>p.priority-d.priority)];const f=e.value.findLastIndex(p=>p.graphType==="edge"),E=e.value.slice(0,f+1),S=e.value.slice(f+1);for(const p of E)p.shape.drawShape(l);for(const p of E)(v=(T=p.shape).drawTextAreaMatte)==null||v.call(T,l);for(const p of E)(c=(i=p.shape).drawText)==null||c.call(i,l);for(const p of S)p.shape.draw(l);a("onRepaint",l,"loop")},n=setInterval(t,1e3/60);return fe(()=>{clearInterval(n)}),setTimeout(t,1e3),{aggregator:e,updateAggregator:s,getSchemaItemsByCoordinates:l=>e.value.sort((b,f)=>b.priority-f.priority).filter(b=>{var f,E;return b.shape.shapeHitbox(l)||((E=(f=b.shape).textHitbox)==null?void 0:E.call(f,l))})}},ct={broadcast:!0,focus:!0,history:!0},dt={broadcast:!0,focus:!1,history:!0},ie={broadcast:!0,history:!0},ce={broadcast:!0,focus:!1,history:!0},de={broadcast:!0,history:!0},lt={broadcast:!0},gt={label:""},ft=({nodes:r,edges:a,nodeMap:e,edgeMap:s,emit:t,settings:n})=>{const y=d=>e.value.get(d),l=d=>s.value.get(d),b=(d,g={})=>{if(d!=null&&d.id&&y(d.id)){console.warn("prevented adding a node with an existing id, this shouldn't happen");return}const o={...ct,...g},h=n.value.newNodeLabelGetter??we({nodes:r}),u={id:d.id??Z(),label:d.label??h(),x:d.x??0,y:d.y??0};return r.value.push(u),t("onNodeAdded",u,o),t("onStructureChange",r.value,a.value),u},f=(d,g={})=>{if(d.length===0)return;const o={...dt,...g},h=[];for(const u of d){const m=b(u,{focus:!1,broadcast:!1,history:!1});m&&h.push(m)}h.length!==0&&t("onBulkNodeAdded",h,o)},E=(d,g={})=>{const o={...ce,...g},{isGraphDirected:h}=n.value,[u,m]=[y(d.from),y(d.to)];if(!u||!m)return;if(h){if(a.value.find(w=>w.from===d.from&&w.to===d.to))return}else if(a.value.find(w=>w.from===d.from&&w.to===d.to||w.from===d.to&&w.to===d.from))return;const A={...gt,id:Z(),...d};return a.value.push(A),t("onEdgeAdded",A,o),t("onStructureChange",r.value,a.value),A},S=(d,g={})=>{if(d.length===0)return;const o={...ce,...g},h=[];for(const u of d){const m=E(u,{broadcast:!1,history:!1});m&&h.push(m)}h.length!==0&&t("onBulkEdgeAdded",h,o)},T=(d,g,o={})=>{const h=y(d);if(!h)return;const u={...lt,...o};h.x=g.x,h.y=g.y,t("onNodeMoved",h,u)},v=(d,g={})=>{const o=y(d);if(!o)return;const h={...ie,...g},m=Ce(o.id,{edges:a,settings:n}).map(A=>c(A.id,{broadcast:!1,history:!1})).filter(Boolean);return r.value=r.value.filter(A=>A.id!==o.id),t("onNodeRemoved",o,m,h),t("onStructureChange",r.value,a.value),[o,m]},i=(d,g={})=>{if(d.length===0)return;const o={...ie,...g},h=[],u=[];for(const m of d){const A=v(m,{broadcast:!1,history:!1});if(!A)continue;const[D,w]=A;h.push(D),u.push(...w)}h.length!==0&&t("onBulkNodeRemoved",h,u,o)},c=(d,g={})=>{const o=l(d);if(!o)return;const h={...de,...g};return a.value=a.value.filter(u=>u.id!==o.id),t("onEdgeRemoved",o,h),t("onStructureChange",r.value,a.value),o};return{getNode:y,getEdge:l,addNode:b,addEdge:E,moveNode:T,removeNode:v,removeEdge:c,bulkAddNode:f,bulkRemoveNode:i,bulkAddEdge:S,bulkRemoveEdge:(d,g={})=>{if(d.length===0)return;const o={...de,...g},h=[];for(const u of d){const m=c(u,{broadcast:!1,history:!1});m&&h.push(m)}if(h.length!==0)return t("onBulkEdgeRemoved",h,o),h}}},ht=({subscribe:r,canvas:a,graphAtMousePosition:e})=>{const s=C(!1),t=C(!1),n=C({node:"grab",edge:"pointer","node-anchor":"grab","encapsulated-node-box":"move"}),y=C(),l=U(()=>!!y.value),b=T=>{y.value=T},f=()=>{y.value=void 0},E=T=>{var i;if(!T)return"default";if(l.value)return((i=y.value)==null?void 0:i.call(y,T))??!1?"pointer":"default";const v=n.value[T.graphType]??"default";return v==="grab"&&s.value?"grabbing":v},S=({items:T})=>{if(!a.value||t.value)return;const v=T.at(-1);a.value.style.cursor=E(v)};return r("onMouseDown",T=>{s.value=!0,S(T)}),r("onMouseUp",T=>{s.value=!1,S(T)}),r("onMouseMove",S),J(n,()=>{S({items:e.value.items})},{deep:!0}),{graphToCursorMap:n,activateCursorSelectMode:b,deactivateCursorSelectMode:f,graphCursorDisabled:t}},vt=(r,a={})=>{const e=C({...$.light,...a.theme}),s=ze(),t=at(e,s),n=C({...rt,...a.settings}),y=je(),{subscribe:l,unsubscribe:b,emit:f}=Ve(y),E=C(!0);Me(r,()=>{E.value=!1}),l("onMouseDown",()=>{E.value=!0});const S=C([]),T=C([]),v=C({coords:{x:0,y:0},items:[]}),i=ht({canvas:r,subscribe:l,graphAtMousePosition:v}),c=x=>{const B=be(r),F=ke(x,B);v.value={coords:F,items:u(F)}},p=x=>({...v.value,event:x}),d={click:x=>f("onClick",p(x)),mousemove:x=>f("onMouseMove",p(x)),mousedown:x=>f("onMouseDown",p(x)),mouseup:x=>f("onMouseUp",p(x)),dblclick:x=>f("onDblClick",p(x)),contextmenu:x=>f("onContextMenu",p(x))},g={keydown:x=>f("onKeyDown",x),keyup:x=>f("onKeyUp",x)},{aggregator:o,updateAggregator:h,getSchemaItemsByCoordinates:u}=it({canvas:r,emit:f}),m=x=>{const B={edges:T,getNode:w,getEdge:k,getTheme:t,settings:n},F=T.value.map(K=>He(K,B)).filter(Boolean).map((K,X)=>({...K,priority:X*10})),ye=S.value.map(K=>We(K,t)).filter(Boolean).map((K,X)=>({...K,priority:X*10+1e3}));return x.push(...F),x.push(...ye),x};h.push(m),Ie(()=>{if(!r.value)throw new Error("canvas element not found");r.value.addEventListener("mousemove",c);for(const[x,B]of Object.entries(d))r.value.addEventListener(x,B);for(const[x,B]of Object.entries(g))document.addEventListener(x,B)}),De(()=>{if(!r.value)throw new Error("Canvas element not found");r.value.removeEventListener("mousemove",c);for(const[x,B]of Object.entries(d))r.value.removeEventListener(x,B);for(const[x,B]of Object.entries(g))document.removeEventListener(x,B)});const{nodeIdToNodeMap:A,edgeIdToEdgeMap:D}=ut(S,T),{getNode:w,getEdge:k,addNode:N,addEdge:M,moveNode:I,removeNode:O,removeEdge:_,bulkAddNode:L,bulkRemoveNode:W,bulkAddEdge:P,bulkRemoveEdge:z}=ft({nodes:S,edges:T,nodeMap:A,edgeMap:D,emit:f,settings:n}),R=(x,B)=>{const F=u({x,y:B}).pop();if(F&&F.graphType==="node")return w(F.id)};let G;l("onMouseMove",({items:x})=>{const B=x.at(-1);if(!B||B.graphType!=="node")return;const F=w(B.id);F!==G&&(f("onNodeHoverChange",F,G),G=F)});const q=x=>(G&&he(G.id,x),x);h.push(q);const j=()=>{S.value=[],T.value=[],f("onGraphReset")};l("onGraphReset",()=>f("onStructureChange",S.value,T.value));const te=C(H(e.value));J(e,x=>{const B=ee(te.value,e.value);B&&(te.value=H(x),f("onThemeChange",B))},{deep:!0});const oe=C(H(n.value));return J(n,x=>{const B=ee(oe.value,x);B&&(oe.value=H(n.value),f("onSettingsChange",B))},{deep:!0}),{nodes:S,edges:T,getNode:w,getEdge:k,addNode:N,addEdge:M,moveNode:I,removeNode:O,removeEdge:_,bulkAddNode:L,bulkRemoveNode:W,bulkAddEdge:P,bulkRemoveEdge:z,getSchemaItemsByCoordinates:u,getNodeByCoordinates:R,eventBus:y,subscribe:l,unsubscribe:b,emit:f,updateAggregator:h,aggregator:o,theme:e,getTheme:t,themeMap:s,settings:n,reset:j,canvas:r,canvasFocused:E,graphAtMousePosition:v,updateGraphAtMousePosition:c,...i}},pt={focus:!0},mt={focus:!0},le=100,ge=3,bt=(r,a={})=>{const e=vt(r,a),s=C([]),t=C([]),n=i=>{s.value.push(i),s.value.length>le&&s.value.shift()},y=i=>{t.value.push(i),t.value.length>le&&t.value.shift()};e.subscribe("onNodeAdded",(i,{history:c})=>{c&&n({action:"add",affectedItems:[{graphType:"node",data:i}]})}),e.subscribe("onBulkNodeAdded",(i,{history:c})=>{c&&n({action:"add",affectedItems:i.map(p=>({graphType:"node",data:p}))})}),e.subscribe("onNodeRemoved",(i,c,{history:p})=>{if(!p)return;const d=c.map(g=>({graphType:"edge",data:g}));n({action:"remove",affectedItems:[{graphType:"node",data:i},...d]})}),e.subscribe("onBulkNodeRemoved",(i,c,{history:p})=>{if(!p)return;const d=i.map(o=>({graphType:"node",data:o})),g=c.map(o=>({graphType:"edge",data:o}));n({action:"remove",affectedItems:[...d,...g]})}),e.subscribe("onEdgeAdded",(i,{history:c})=>{c&&n({action:"add",affectedItems:[{graphType:"edge",data:i}]})}),e.subscribe("onBulkEdgeAdded",(i,{history:c})=>{c&&n({action:"add",affectedItems:i.map(p=>({graphType:"edge",data:p}))})}),e.subscribe("onEdgeRemoved",(i,{history:c})=>{c&&n({action:"remove",affectedItems:[{graphType:"edge",data:i}]})}),e.subscribe("onBulkEdgeRemoved",(i,{history:c})=>{c&&n({action:"remove",affectedItems:i.map(p=>({graphType:"edge",data:p}))})});const l=C();e.subscribe("onGroupDragStart",(i,c)=>{l.value={startingCoordinates:c,nodes:i}}),e.subscribe("onGroupDrop",(i,c)=>{if(!l.value)throw new Error("dropped a group we didn't know was being dragged");if(l.value.nodes.length!==i.length)throw new Error("group size mismatch");const p=l.value.startingCoordinates.y-c.y,d=l.value.startingCoordinates.x-c.x;Math.sqrt(p**2+d**2)<ge||n({action:"move",affectedItems:l.value.nodes.map(o=>({graphType:"node",data:{id:o.id,from:{x:o.x+d,y:o.y+p},to:{x:o.x,y:o.y}}}))})});const b=C();e.subscribe("onNodeDragStart",i=>{b.value={id:i.id,from:{x:i.x,y:i.y},to:{x:i.x,y:i.y}}}),e.subscribe("onNodeDrop",i=>{if(!b.value)throw new Error("dropped a node we didn't know was being dragged");if(b.value.id!==i.id)throw new Error("node ID mismatch");b.value.to={x:i.x,y:i.y};const c=b.value.from.y-b.value.to.y,p=b.value.from.x-b.value.to.x;Math.sqrt(c**2+p**2)<ge||n({action:"move",affectedItems:[{graphType:"node",data:b.value}]})});const f=(i={})=>{const c=s.value.pop();if(c)return y(c),S(c),e.emit("onUndo",c,{...pt,...i}),c},E=(i={})=>{const c=t.value.pop();if(c)return n(c),T(c),e.emit("onRedo",c,{...mt,...i}),c},S=i=>{if(i.action==="add")for(const c of i.affectedItems)c.graphType==="node"?e.removeNode(c.data.id,{history:!1}):c.graphType==="edge"&&e.removeEdge(c.data.id,{history:!1});else if(i.action==="remove")for(const c of i.affectedItems)c.graphType==="node"?e.addNode(c.data,{history:!1,focus:!1}):c.graphType==="edge"&&e.addEdge(c.data,{history:!1,focus:!1});else if(i.action==="move"){for(const c of i.affectedItems)if(c.graphType==="node"){const{from:p,id:d}=c.data;e.moveNode(d,{x:p.x,y:p.y})}}},T=i=>{if(i.action==="add")for(const c of i.affectedItems)c.graphType==="node"?e.addNode(c.data,{history:!1,focus:!1}):c.graphType==="edge"&&e.addEdge(c.data,{history:!1,focus:!1});else if(i.action==="remove")for(const c of i.affectedItems)c.graphType==="node"?e.removeNode(c.data.id,{history:!1}):c.graphType==="edge"&&e.removeEdge(c.data.id,{history:!1});else if(i.action==="move"){for(const c of i.affectedItems)if(c.graphType==="node"){const{to:p,id:d}=c.data;e.moveNode(d,{x:p.x,y:p.y})}}},v=()=>{s.value=[],t.value=[]};return{...e,undo:f,redo:E,canUndo:U(()=>s.value.length>0),canRedo:U(()=>t.value.length>0),undoStack:s,redoStack:t,addToUndoStack:n,addToRedoStack:y,clearHistory:v}},yt=["node","edge"],St="use-focus-graph",Tt=(r,a={})=>{const e=bt(r,a),{setTheme:s}=ve(e,St),t=C(new Set),n=C(!1),y=o=>{const h=o.filter(D=>!e.settings.value.focusBlacklist.includes(D));if(h.length===t.value.size&&h.every(D=>t.value.has(D)))return;const A=new Set([...t.value]);t.value=new Set(h),e.emit("onFocusChange",t.value,A)},l=o=>{if(t.value.has(o)||e.settings.value.focusBlacklist.includes(o))return;const m=new Set([...t.value]);t.value.add(o),e.emit("onFocusChange",t.value,m)},b=o=>{var u,m;const h=be(e.canvas);(m=(u=o.shape).activateTextArea)==null||m.call(u,h,A=>{const D=e.getEdge(o.id);if(!D)throw new Error("textarea only implemented for edges");const w=e.settings.value.edgeInputToLabel(A);w===void 0||D.label===w||(D.label=w,e.emit("onEdgeLabelChange",D),e.emit("onStructureChange",e.nodes.value,e.edges.value))})},f=()=>{const o=Array.from(t.value),h=o.filter(u=>e.getNode(u)||e.getEdge(u));h.length!==o.length&&y(h)},E=({items:o,coords:h})=>{var w,k;const u=o.at(-1);if(!u)return n.value?void 0:S();if(((k=(w=u.shape).textHitbox)==null?void 0:k.call(w,h))&&e.settings.value.edgeLabelsEditable&&u.graphType==="edge")return S(),b(u);yt.some(N=>N===u.graphType)&&(n.value?l(u.id):y([u.id]))},S=()=>y([]),T=()=>{const o=e.nodes.value.map(u=>u.id),h=e.edges.value.map(u=>u.id);y([...o,...h])},v=({id:o},{focus:h})=>{h&&y([o])},i=o=>t.value.has(o);s("nodeColor",o=>{if(i(o.id))return e.getTheme("nodeFocusColor",o)}),s("nodeBorderColor",o=>{if(i(o.id))return e.getTheme("nodeFocusBorderColor",o)}),s("nodeTextColor",o=>{if(i(o.id))return e.getTheme("nodeFocusTextColor",o)}),s("edgeColor",o=>{if(i(o.id))return e.getTheme("edgeFocusColor",o)}),s("edgeTextColor",o=>{if(i(o.id))return e.getTheme("edgeFocusTextColor",o)}),s("nodeAnchorColor",o=>{if(i(o.id))return e.getTheme("nodeAnchorColorWhenParentFocused",o)});const c=o=>{o.key==="Shift"&&(n.value=!0)},p=o=>{o.key==="Shift"&&(n.value=!1)},d=()=>{e.subscribe("onNodeAdded",v),e.subscribe("onEdgeAdded",v),e.subscribe("onMouseDown",E),e.subscribe("onGraphReset",S),e.subscribe("onKeyDown",c),e.subscribe("onKeyUp",p),e.subscribe("onStructureChange",f)},g=()=>{e.unsubscribe("onNodeAdded",v),e.unsubscribe("onEdgeAdded",v),e.unsubscribe("onMouseDown",E),e.unsubscribe("onGraphReset",S),e.unsubscribe("onKeyDown",c),e.unsubscribe("onKeyUp",p),e.unsubscribe("onStructureChange",f),S()};return e.subscribe("onSettingsChange",o=>{o.focusable===!1?g():o.focusable===!0&&d()}),e.settings.value.focusable&&d(),{...e,focusedItemIds:Q(t),setFocus:y,resetFocus:S,addToFocus:l,isFocused:i,focusAll:T,focusedNodes:U(()=>e.nodes.value.filter(o=>i(o.id))),focusedEdges:U(()=>e.edges.value.filter(o=>i(o.id)))}},Et=(r,a={})=>{const e=Tt(r,a),s=C(),t=({items:f,coords:E})=>{const S=f.at(-1);if(!S||S.graphType!=="node")return;const T=e.getNode(S.id);T&&(s.value={node:T,coords:E},e.emit("onNodeDragStart",T))},n=()=>{s.value&&(e.emit("onNodeDrop",s.value.node),s.value=void 0)},y=({coords:f})=>{if(!s.value)return;const{node:E,coords:S}=s.value,T=f.x-S.x,v=f.y-S.y;e.moveNode(E.id,{x:E.x+T,y:E.y+v}),s.value.coords=f},l=()=>{e.subscribe("onMouseDown",t),e.subscribe("onMouseUp",n),e.subscribe("onMouseMove",y)},b=()=>{e.unsubscribe("onMouseDown",t),e.unsubscribe("onMouseUp",n),e.unsubscribe("onMouseMove",y),s.value&&n()};return e.subscribe("onSettingsChange",f=>{f.draggable===!1?b():f.draggable===!0&&l()}),e.settings.value.draggable&&l(),{...e,activeDragNode:U(()=>{var f;return(f=s.value)==null?void 0:f.node})}},Nt=(r,a={})=>{const e=Et(r,a),s=C(),t=C(),n=()=>{s.value=void 0,t.value=void 0},y=u=>{if(e.activeDragNode.value)return[];const{getTheme:m}=e,A=m("nodeAnchorColor",u),D=m("nodeAnchorRadius",u),w=[];for(const k of l.value){const{x:N,y:M}=k,I={at:{x:N,y:M},radius:D,color:A};t.value&&t.value.direction===k.direction&&(I.at.x=t.value.x,I.at.y=t.value.y);const O=pe(I);w.push({id:k.id,graphType:"node-anchor",shape:O,priority:1/0})}return w},l=C([]),b=u=>{if(!u)return l.value=[];const{getTheme:m}=e,A=m("nodeAnchorRadius",u),D=m("nodeSize",u),w=m("nodeBorderWidth",u),k=D-A/3+w/2;l.value=[{x:u.x,y:u.y-k,direction:"north"},{x:u.x+k,y:u.y,direction:"east"},{x:u.x,y:u.y+k,direction:"south"},{x:u.x-k,y:u.y,direction:"west"}].map(N=>({...N,id:Z()}))},f=({items:u})=>{const m=u.at(-1);if(!m||m.graphType!=="node-anchor")return;const{id:A}=m;return l.value.find(D=>D.id===A)},E=()=>{if(!s.value||!t.value)return;const{x:u,y:m}=t.value,A={x:s.value.x,y:s.value.y},D={x:u,y:m},{getTheme:w}=e,k=w("linkPreviewColor",s.value,t.value),N=w("linkPreviewWidth",s.value,t.value);return{id:"link-preview",graphType:"link-preview",shape:me({start:A,end:D,color:k,width:N})}},S=({items:u})=>{if(t.value)return;const m=u.at(-1);if(!m)return n();if(m.graphType!=="node")return;const A=e.getNode(m.id);if(!A)throw new Error("node in aggregator but not in graph");const D=e.isFocused(A.id),w=e.focusedNodes.value.length>1;if(D&&w)return n();s.value=A,b(A)},T=u=>{if(!s.value)return;const m=f(u);m&&(t.value=m,e.emit("onNodeAnchorDragStart",s.value,m))},v=({coords:u})=>{if(!t.value)return;const{x:m,y:A}=u;t.value.x=m,t.value.y=A},i=()=>{if(t.value){if(!s.value)throw new Error("active anchor without parent node")}else return;e.emit("onNodeAnchorDrop",s.value,t.value),n()},c=u=>{if(!s.value)return u;const m=y(s.value);for(const A of m)u.push(A);return u},p=u=>{var k;if(!s.value||!t.value)return u;const{id:m}=s.value;he(m,u);const A=(k=u.find(N=>N.id===m))==null?void 0:k.priority;if(!A)return u;const D=E();if(!D)return u;const w={...D,priority:A-.1};return u.push(w),u};e.updateAggregator.push(c),e.updateAggregator.push(p);const d=u=>{var m;((m=s.value)==null?void 0:m.id)===u.id&&n()},g=()=>{if(!s.value)return;const u=e.isFocused(s.value.id),m=e.focusedNodes.value.length>1;u&&m&&n()},o=()=>{e.subscribe("onNodeRemoved",d),e.subscribe("onNodeMoved",n),e.subscribe("onNodeDrop",b),e.subscribe("onMouseMove",S),e.subscribe("onMouseMove",v),e.subscribe("onMouseDown",T),e.subscribe("onMouseUp",i),e.subscribe("onFocusChange",g)},h=()=>{e.unsubscribe("onNodeRemoved",d),e.unsubscribe("onNodeMoved",n),e.unsubscribe("onNodeDrop",b),e.unsubscribe("onMouseMove",S),e.unsubscribe("onMouseMove",v),e.unsubscribe("onMouseDown",T),e.unsubscribe("onMouseUp",i),e.unsubscribe("onFocusChange",g)};return e.subscribe("onSettingsChange",u=>{u.nodeAnchors===!0?o():u.nodeAnchors===!1&&h()}),e.settings.value.nodeAnchors&&o(),{...e,nodeAnchorActiveAnchor:Q(t),nodeAnchorParentNode:Q(s)}},xt="use-marquee-graph",At={THEME_ID:xt},wt=(r,a={})=>{const e=Nt(r,a),s=C(),t=C(),n=C(),{setTheme:y,removeTheme:l}=ve(e,At.THEME_ID),b=()=>y("nodeAnchorColor",V.TRANSPARENT),f=()=>l("nodeAnchorColor"),E=N=>{const{width:M,height:I}=N;return Math.abs(M*I)},S=({items:N,coords:M})=>{const I=N.at(-1);(I==null?void 0:I.graphType)!=="encapsulated-node-box"&&f(),I||p(M)},T=({items:N,coords:M})=>{if(!n.value)return;const I=N.at(-1);if((I==null?void 0:I.graphType)!=="encapsulated-node-box")return;const O=M.x-n.value.x,_=M.y-n.value.y;n.value=M;for(const L of e.focusedNodes.value)e.moveNode(L.id,{x:L.x+O,y:L.y+_});o()},v=({items:N,coords:M})=>{if(s.value)return;const I=N.at(-1);(I==null?void 0:I.graphType)==="encapsulated-node-box"&&(n.value=M,e.emit("onGroupDragStart",e.focusedNodes.value,M))},i=()=>{n.value&&(e.emit("onGroupDrop",e.focusedNodes.value,n.value),n.value=void 0)},c=()=>t.value={at:{x:1/0,y:1/0},width:0,height:0},p=N=>{b(),e.graphCursorDisabled.value=!0,s.value={at:N,width:0,height:0},c()},d=()=>{s.value&&(s.value=void 0,e.graphCursorDisabled.value=!1,f())},g=N=>{if(E(N)<100)return;const I=[];for(const{id:O,shape:_,graphType:L}of e.aggregator.value){const{marqueeSelectableGraphTypes:W}=e.settings.value;if(!W.includes(L))continue;_.efficientHitbox(N)&&I.push(O)}e.setFocus(I)},o=()=>{if(!t.value)return;if(e.focusedNodes.value.length<2)return c();let N=1/0,M=1/0,I=-1/0,O=-1/0;for(const _ of e.focusedNodes.value){const L=e.getTheme("nodeSize",_),W=e.getTheme("nodeBorderWidth",_),P=L+W/2,{x:z,y:R}=_;N=Math.min(N,z-P),M=Math.min(M,R-P),I=Math.max(I,z+P),O=Math.max(O,R+P)}N<1/0&&M<1/0&&I>-1/0&&O>-1/0?(t.value.at.x=N,t.value.at.y=M,t.value.width=I-N,t.value.height=O-M):(t.value.width=0,t.value.height=0)},h=({coords:N})=>{if(!s.value)return;const{x:M,y:I}=N;s.value.width=M-s.value.at.x,s.value.height=I-s.value.at.y,g(s.value)},u=N=>({id:"marquee-box",graphType:"marquee-box",shape:re({...N,color:e.getTheme("marqueeSelectionBoxColor"),stroke:{color:e.getTheme("marqueeSelectionBoxBorderColor"),width:2}}),priority:1/0}),m=N=>{if(!s.value)return N;const M=u(s.value);return N.push(M),N},A=N=>({id:"encapsulated-node-box",graphType:"encapsulated-node-box",shape:re({...N,color:e.getTheme("marqueeEncapsulatedNodeBoxColor"),stroke:{color:e.getTheme("marqueeEncapsulatedNodeBoxBorderColor"),width:2}}),priority:1/0}),D=N=>{if(!t.value)return N;const M=A(t.value);return N.push(M),N};e.updateAggregator.push(D),e.updateAggregator.push(m);const w=()=>{e.subscribe("onFocusChange",o),e.subscribe("onMouseDown",S),e.subscribe("onMouseUp",d),e.subscribe("onContextMenu",d),e.subscribe("onMouseMove",h),e.subscribe("onMouseDown",v),e.subscribe("onMouseUp",i),e.subscribe("onMouseMove",T),e.subscribe("onUndo",o),e.subscribe("onRedo",o)},k=()=>{e.unsubscribe("onFocusChange",o),e.unsubscribe("onMouseDown",S),e.unsubscribe("onMouseUp",d),e.unsubscribe("onContextMenu",d),e.unsubscribe("onMouseMove",h),e.unsubscribe("onMouseDown",v),e.unsubscribe("onMouseUp",i),e.unsubscribe("onMouseMove",T),e.unsubscribe("onUndo",o),e.unsubscribe("onRedo",o),s.value&&d()};return e.subscribe("onSettingsChange",N=>{N.marquee===!0?w():N.marquee===!1&&k()}),e.settings.value.marquee&&w(),{...e,updateEncapsulatedNodeBox:o}},Ct=(r,a={})=>{const e=wt(r,a),s=C(Be[0]),t=C(Re[1]),n=C(!1),y=C(new Set),l=C([]),b=C([]),f=C(!1),E=C(),S=C(!1),T=()=>{b.value=[]},v=({coords:o})=>{f.value=!0,E.value=o,l.value=[o]},i=({coords:o})=>{if(!(!f.value||!E.value)){if(n.value){const h=b.value.filter(u=>Y.scribble(u).hitbox(o));for(const u of h)y.value.add(u.id);return}E.value=o,l.value.push(o)}},c=()=>{if(f.value&&(f.value=!1,E.value=void 0,l.value.length!==0)){if(n.value){b.value=b.value.filter(o=>!y.value.has(o.id)),y.value.clear();return}b.value.push({id:Z(),type:"draw",points:l.value,color:s.value,brushWeight:t.value}),l.value=[]}};J(n,()=>{e.canvas.value&&(e.canvas.value.style.cursor=n.value?"none":"crosshair")});const p=o=>{if(!S.value)return o;if(n.value){const h=Y.circle({at:e.graphAtMousePosition.value.coords,radius:10,color:V.TRANSPARENT,stroke:{color:V.WHITE+"60",width:2}});o.push({graphType:"annotation",id:h.id,shape:h,priority:5050})}else if(l.value.length>0){const h=Y.scribble({type:"draw",points:l.value,color:s.value,brushWeight:t.value});o.push({graphType:"annotation",id:h.id,shape:h,priority:5001})}for(const h of b.value){const u=y.value.has(h.id);o.push({graphType:"annotation",id:h.id,shape:Y.scribble({...h,color:h.color+(u?"50":"")}),priority:5e3})}return o};return e.updateAggregator.push(p),{...e,clearAnnotations:T,annotationActive:S,annotationErasing:n,annotationColor:s,annotationBrushWeight:t,activateAnnotation:()=>{e.canvas.value&&(S.value=!0,e.settings.value.userEditable=!1,e.settings.value.marquee=!1,e.settings.value.focusable=!1,e.graphCursorDisabled.value=!0,e.canvas.value.style.cursor="crosshair",e.subscribe("onMouseDown",v),e.subscribe("onMouseMove",i),e.subscribe("onMouseUp",c))},deactivateAnnotation:()=>{e.canvas.value&&(S.value=!1,n.value=!1,e.settings.value.userEditable=!0,e.settings.value.marquee=!0,e.settings.value.focusable=!0,e.graphCursorDisabled.value=!1,e.canvas.value.style.cursor="default",e.unsubscribe("onMouseDown",v),e.unsubscribe("onMouseMove",i),e.unsubscribe("onMouseUp",c))}}},Mt=(r=!1)=>{const a=l=>l.key===" "?"Space":l.key.length>1||r?l.key:l.key.toUpperCase(),e=C(""),s=U(()=>{let l;return e.value.split("+").filter(b=>{const f=b===l;return l=b,!f}).join("+")}),t=l=>{e.value.length>0&&(e.value+="+"),e.value+=a(l)},n=()=>{e.value=""},y=l=>s.value===l;return document.addEventListener("keydown",t),document.addEventListener("keyup",n),fe(()=>{document.removeEventListener("keydown",t),document.removeEventListener("keyup",n)}),{isPressed:y,currentKeyString:e}},It=(r,a={})=>{const e=Ct(r,a),s=({coords:v,event:i})=>{e.addNode(v),setTimeout(()=>e.updateGraphAtMousePosition(i),10)},t=(v,i)=>{const p=e.getSchemaItemsByCoordinates(i).findLast(g=>g.graphType==="node");if(!p)return;const d=e.getNode(p.id);if(d&&!(e.settings.value.userAddedEdgeRuleNoSelfLoops&&v.id===d.id)){if(e.settings.value.userAddedEdgeRuleOneEdgePerPath){const g=e.edges.value.find(u=>u.from===v.id&&u.to===d.id),o=e.edges.value.find(u=>u.from===d.id&&u.to===v.id);if(g||o)return}e.addEdge({from:v.id,to:d.id,label:e.settings.value.userAddedEdgeLabel})}},n=()=>{e.bulkRemoveNode([...e.focusedItemIds.value]),e.bulkRemoveEdge([...e.focusedItemIds.value])},y={Mac:{"Meta+Z":()=>e.undo(),"Shift+Meta+Z":()=>e.redo(),Backspace:n,"Meta+A":e.focusAll,Escape:e.resetFocus},Windows:{"Control+Z":()=>e.undo(),"Shift+Control+Z":()=>e.redo(),Backspace:n,"Control+A":e.focusAll,Escape:e.resetFocus}},l=window.navigator.userAgent.includes("Mac")?"Mac":"Windows",{isPressed:b}=Mt(),E={onDblClick:s,onKeyDown:()=>{if(e.settings.value.userEditable===!1||e.canvasFocused.value===!1)return;const v=y[l];for(const i in v)b(i)&&v[i]()},onNodeAnchorDrop:t},S=()=>{for(const v in E)e.subscribe(v,E[v]);e.settings.value.nodeAnchors=!0,e.settings.value.edgeLabelsEditable=!0},T=()=>{for(const v in E)e.unsubscribe(v,E[v]);e.settings.value.nodeAnchors=!1,e.settings.value.edgeLabelsEditable=!1};return e.settings.value.userEditable&&S(),e.subscribe("onSettingsChange",v=>{v.userEditable===!0?S():v.userEditable===!1&&T()}),e},Dt=(r,a={})=>{const e=It(r,a),s={get:()=>JSON.parse(localStorage.getItem(e.settings.value.persistentStorageKey+"-nodes")??"[]"),set:g=>{localStorage.setItem(e.settings.value.persistentStorageKey+"-nodes",JSON.stringify(g))}},t={get:()=>JSON.parse(localStorage.getItem(e.settings.value.persistentStorageKey+"-edges")??"[]"),set:g=>{localStorage.setItem(e.settings.value.persistentStorageKey+"-edges",JSON.stringify(g))}},n={get:()=>JSON.parse(localStorage.getItem(e.settings.value.persistentStorageKey+"-theme")??"{}"),set:g=>{localStorage.setItem(e.settings.value.persistentStorageKey+"-theme",JSON.stringify(g))}},y={get:()=>JSON.parse(localStorage.getItem(e.settings.value.persistentStorageKey+"-settings")??"{}"),set:g=>{localStorage.setItem(e.settings.value.persistentStorageKey+"-settings",JSON.stringify(g))}},l=async()=>{await new Promise(g=>setTimeout(g,10)),s.set(e.nodes.value),t.set(e.edges.value)};let b=e.settings.value.persistentStorageKey;const f=async()=>{const g=e.settings.value.persistentStorageKey;if(b!==g){b=g;return}await new Promise(o=>setTimeout(o,10)),e.settings.value.persistentTrackTheme&&n.set(e.theme.value),e.settings.value.persistentTrackSettings&&y.set(e.settings.value),b=g},E=()=>{e.nodes.value=s.get(),e.edges.value=t.get(),e.settings.value.persistentTrackTheme&&(e.theme.value=Object.assign(e.theme.value,n.get())),e.settings.value.persistentTrackSettings&&(e.settings.value=Object.assign(e.settings.value,y.get())),queueMicrotask(()=>e.emit("onStructureChange",e.nodes.value,e.edges.value))},S=["onStructureChange","onNodeDrop","onGroupDrop","onGraphReset"],T=["onThemeChange","onSettingsChange"],v=()=>{T.forEach(g=>e.subscribe(g,f))},i=()=>{T.forEach(g=>e.unsubscribe(g,f))},c=()=>{S.forEach(g=>e.subscribe(g,l))},p=()=>{S.forEach(g=>e.unsubscribe(g,l))},d=()=>{i(),p()};return e.subscribe("onSettingsChange",g=>{if(d(),"persistent"in g&&!g.persistent)return;if("persistent"in g&&g.persistent){E(),c(),(e.settings.value.persistentTrackSettings||e.settings.value.persistentTrackTheme)&&v();return}"persistentStorageKey"in g&&E(),c(),(e.settings.value.persistentTrackSettings||e.settings.value.persistentTrackTheme)&&v()}),e.settings.value.persistent&&(E(),c(),(e.settings.value.persistentTrackSettings||e.settings.value.persistentTrackTheme)&&v()),{...e,trackGraphState:l,trackOptions:f}},Rt=(r,a={})=>{const e=H((a==null?void 0:a.theme)??{}),s=Dt(r,a);return Ke(s,e),s},Ot=Oe({__name:"Graph",props:{graph:{}},emits:["graphRef"],setup(r,{emit:a}){const e=r,s=a,t=l=>s("graphRef",l),n=C(e.graph.getTheme("graphBgPatternColor")),y=C(e.graph.getTheme("graphBgColor"));return e.graph.subscribe("onThemeChange",l=>{const{graphBgPatternColor:b,graphBgColor:f}=l;b&&(n.value=b),f&&(y.value=f)}),(l,b)=>(Fe(),_e(Ue,{onCanvasRef:t,color:y.value,"pattern-color":n.value},null,8,["color","pattern-color"]))}});export{$ as T,Ot as _,Ye as i,Rt as u};
