import{br as I,bs as nt,bt as k,b9 as E,bu as O,bv as P,bw as Bt,bx as ot,by as R,bz as X,bA as B,bB as L,G as D,bC as Lt,bD as rt,bE as Dt,bF as It,bG as Rt,bH as st,bI as Wt,bJ as _t,bK as z,bL as N,bM as Ft,bN as W,bO as $,bP as S,bQ as tt,f as _,bR as Ot,b0 as zt,J as H,d as Ut,h as Vt,c as Gt,L as Xt,am as Yt,P as qt,o as Nt}from"./index-DZqqfzZN.js";import{t as $t}from"./index-3Bhx9ktt.js";const Kt=n=>{const{at:t,size:e,lineWidth:o,borderRadius:r,...s}=n,c=o/2,[i,l,a,u]=nt(r),d=k({...s,at:{x:t.x-e/2,y:t.y-c},width:e,height:o,borderRadius:[u,l,l,u]}),h=k({...s,at:{x:t.x-c,y:t.y-e/2},width:o,height:e,borderRadius:[i,i,a,a]});return g=>d(g)||h(g)},it=n=>()=>{const{at:t,size:e}=n;return E({at:{x:t.x-e/2,y:t.y-e/2},width:e,height:e})},jt=n=>t=>I(it(n)(),t),Jt=n=>{const{at:t,size:e,rotation:o,fillColor:r,lineWidth:s,borderRadius:c}=n,i=s/2,[l,a,u,d]=nt(c);return h=>{h.save(),h.translate(t.x,t.y),h.rotate(o),O({at:{x:-i,y:-e/2},width:s,height:e/2-i,fillColor:r,borderRadius:[l,l,0,0]})(h),O({at:{x:-e/2,y:-i},width:e,height:s,fillColor:r,borderRadius:[d,a,a,d]})(h),O({at:{x:-i,y:i},width:s,height:e/2-i,fillColor:r,borderRadius:[0,0,u,u]})(h),h.restore()}},Qt={...X,...R,...ot,...Bt},at=P(Qt),Zt=n=>{if(n.lineWidth&&n.lineWidth<0)throw new Error("lineWidth must be positive");const t=at(n),e=B(t.at,t.textArea),o=Jt(t),r=a=>{o(a),e==null||e.drawTextArea(a)},s=Kt(t),c=jt(t),i=a=>(e==null?void 0:e.textHitbox(a))||s(a),l=it(t);return L({name:"cross",draw:r,drawShape:o,hitbox:i,shapeHitbox:s,efficientHitbox:c,getBoundingBox:l,...e})},kt=new Set(["drawTextAreaMatte","drawText","drawTextArea","textHitbox","startTextAreaEdit","name","draw","drawShape","hitbox","shapeHitbox","efficientHitbox","getBoundingBox","getCenterPoint"]),te=({durationMs:n,startedAt:t,delayMs:e})=>{const o=Date.now()-t;return o<e?0:(o-e)/n},ee=({durationMs:n,startedAt:t,delayMs:e})=>{const o=Date.now()-t;return o<e?0:(o-e)%n/n},ne=()=>Math.random().toString(36).substring(2,9),G=(n,t,e)=>o=>{if(n.length===0)return e;if(o<=n[0].progress)return n[0].value;if(o>=n[n.length-1].progress)return n[n.length-1].value;for(let r=0;r<n.length-1;r++){const s=n[r],c=n[r+1];if(o>=s.progress&&o<=c.progress){const i=(o-s.progress)/(c.progress-s.progress),l=s.easing??t;return s.value+l(i)*(c.value-s.value)}}return e},oe=(n,t,e)=>(o,r)=>{const s=o[n];if(typeof s!="number")throw`ðŸ˜³! prop ${n} said to be a number was not at runtime! got ${s}`;const c=t[n].map(l=>({...l,value:typeof l.value=="function"?l.value(s,o):l.value}));return G(c,e,s)(r)},re=n=>ct(D(n)),ct=n=>n.isValid(),U=(n,t,e)=>o=>{if(n.length===0)return e;if(!n.map(s=>D(s.value)).every(ct))throw new Error("Invalid color provided in keyframe.");for(let s=0;s<n.length-1;s++){const c=n[s],i=n[s+1];if(o>=c.progress&&o<=i.progress){const l=i.progress-c.progress,a=(o-c.progress)/l,d=(c.easing??t)(a),h=D(c.value).toRgb(),g=D(i.value).toRgb(),f=h.r+(g.r-h.r)*d,p=h.g+(g.g-h.g)*d,y=h.b+(g.b-h.b)*d,m=h.a+(g.a-h.a)*d;return D({r:f,g:p,b:y,a:m}).toRgbString()}}return e},se=(n,t,e)=>(o,r)=>{const s=o[n];if(!(typeof s=="string"&&re(s)))throw`ðŸ˜³! prop ${n} said to be a color was not at runtime! got ${s}`;const i=t[n].map(a=>({...a,value:typeof a.value=="function"?a.value(s,o):a.value}));return U(i,e,s)(r)},ie=(n,t,e)=>o=>{const r=n.map(g=>({...g,value:g.value.color})),s=n.map(g=>({...g,value:g.value.activeColor})),c=n.map(g=>({...g,value:g.value.textBlock.color})),i=n.map(g=>({...g,value:g.value.textBlock.fontSize})),l=U(r,t,e.color),a=U(c,t,e.textBlock.color),u=G(i,t,e.textBlock.fontSize),d=U(s,t,e.activeColor),{textBlock:h}=e;return{textBlock:{...h,color:a(o),fontSize:u(o)},color:l(o),activeColor:d(o)}},ae=(n,t,e)=>(o,r)=>{const s=o[n],c=t[n].map(l=>{var d;const u=(d=Lt(typeof l.value=="function"?l.value(s,o):l.value))==null?void 0:d.textArea;if(!u)throw"received undefined value from resolved text area";return{...l,value:u}});return ie(c,e,s)(r)},ce=(n,t,e)=>o=>{const r=n.map(l=>({value:l.value.x,progress:l.progress})),s=n.map(l=>({value:l.value.y,progress:l.progress})),c=G(r,t,e.x),i=G(s,t,e.y);return{x:c(o),y:i(o)}},le=(n,t,e)=>(o,r)=>{const s=o[n];if(typeof s!="object"||typeof s.x!="number"||typeof s.y!="number")throw`ðŸ˜³! prop ${n} said to be a coordinate was not at runtime! got ${s}`;const c=t[n].map(l=>({...l,value:typeof l.value=="function"?l.value(s,o):l.value}));return ce(c,e,s)(r)},ue={linear:n=>n,in:n=>n*n,out:n=>n*(2-n),"in-out":n=>n<.5?2*n*n:-1+(4-2*n)*n},et=n=>typeof n=="function"?n:ue[n],V=n=>n&&typeof n=="object"&&Object.getPrototypeOf(n)===Object.prototype,de=(...n)=>n.reduce((t,e)=>e==null?t:V(e)?(Object.keys(e).forEach(o=>{V(e[o])&&V(t[o])?t[o]=de(t[o],e[o]):t[o]=e[o]}),t):e,{}),he=["rotation","borderRadius","lineWidth","width","radius"],ge=["fillColor"],fe=["textArea"],pe=["at","start","end"],xe={progress:0,value:n=>n},ye={progress:1,value:n=>n},me="linear",be=n=>{const t={durationMs:n.durationMs,delayMs:(n==null?void 0:n.delayMs)??0,properties:{},validShapes:new Set(n.forShapes)},e=[...new Set(n.keyframes.map(a=>Object.keys(a.properties)).flat())],o=e.reduce((a,u)=>{var h;const d=n.keyframes.map(g=>{const f=g.properties[u],p=V(f),y=p?f.value:f,m=p?f==null?void 0:f.easing:void 0;return{progress:g.progress,value:y,easing:m!==void 0?et(m):m}}).filter(({value:g})=>g!==void 0);return d[0].progress!==0&&d.unshift(xe),((h=d.at(-1))==null?void 0:h.progress)!==1&&d.push(ye),a[u]=d,a},{}),r=a=>{var d;const u=((d=n.easing)==null?void 0:d[a])??me;return et(u)},s=he.filter(a=>e.includes(a));for(const a of s)t.properties[a]=oe(a,o,r(a));const c=ge.filter(a=>e.includes(a));for(const a of c)t.properties[a]=se(a,o,r(a));const i=fe.filter(a=>e.includes(a));for(const a of i)t.properties[a]=ae(a,o,r(a));const l=pe.filter(a=>e.includes(a));for(const a of l)t.properties[a]=le(a,o,r(a));return t},we=n=>{const t=new Map;return{timelineIdToTimeline:t,defineTimeline:o=>{const r=ne(),s=be(o);return t.set(r,s),{play:c=>n.play({...c,timelineId:r}),pause:c=>n.pause({...c,timelineId:r}),resume:c=>n.resume({...c,timelineId:r}),stop:c=>n.stop({...c,timelineId:r}),dispose:()=>t.delete(r)}}}},Se={...R,...X,...ot,arrowHeadSize:rt},lt=P(Se),ut={...Dt,arrowHeadSize:rt},dt=P(ut),ht={...It},Ae=P(ht),ve={...X},gt=P(ve),Ce={...R,brushWeight:3},ft=P(Ce),Me={...R,...X,points:5},pt=P(Me),Te={...R},xt=P(Te),He={arrow:dt,circle:_t,cross:at,ellipse:Wt,image:gt,line:st,rect:Rt,scribble:ft,square:Ae,star:pt,triangle:xt,uturn:lt},yt=n=>t=>{const{start:e,end:o,lineWidth:r,fillColor:s,dash:c=[],fillGradient:i}=n;if(r!==0){if(t.save(),t.beginPath(),t.moveTo(e.x,e.y),t.lineTo(o.x,o.y),t.lineWidth=r,t.strokeStyle=s,i&&i.length>=2){const l=t.createLinearGradient(e.x,e.y,o.x,o.y);i.forEach(({offset:a,color:u})=>{l.addColorStop(a,u)}),t.strokeStyle=l}t.setLineDash(c),t.stroke(),t.closePath(),t.restore()}},mt=n=>t=>{const{pointA:e,pointB:o,pointC:r,fillColor:s,stroke:c,fillGradient:i}=n;if(t.beginPath(),t.moveTo(e.x,e.y),t.lineTo(o.x,o.y),t.lineTo(r.x,r.y),i&&i.length>=2){const l={x:(o.x+r.x)/2,y:(o.y+r.y)/2},a=t.createLinearGradient(l.x,l.y,e.x,e.y);i.forEach(({offset:u,color:d})=>{a.addColorStop(u,d)}),t.fillStyle=a}else t.fillStyle=s;t.fill(),t.closePath(),c&&(t.lineWidth=c.lineWidth,t.strokeStyle=c.color,t.setLineDash(c.dash??[]),t.stroke(),t.setLineDash([]))},Ee=n=>{var C;const{start:t,end:e,lineWidth:o,fillColor:r,dash:s,fillGradient:c,arrowHeadSize:i,arrowHeadShape:l}=n,a=Math.atan2(e.y-t.y,e.x-t.x),{arrowHeadHeight:u,perpLineLength:d}=i(o),h={x:e.x-u*Math.cos(a),y:e.y-u*Math.sin(a)},g={start:t,end:{x:h.x+Math.cos(a),y:h.y+Math.sin(a)},lineWidth:o,fillColor:r,dash:s,fillGradient:c},f=yt(g),p=e,y={x:h.x+d*Math.cos(a+Math.PI/2),y:h.y+d*Math.sin(a+Math.PI/2)},m={x:h.x-d*Math.cos(a+Math.PI/2),y:h.y-d*Math.sin(a+Math.PI/2)},w=l?l(e,u,d).draw:mt({pointA:p,pointB:y,pointC:m,fillColor:c&&c.length?(C=c.at(-1))==null?void 0:C.color:r});return v=>{f(v),w(v)}},bt=n=>t=>z(n,t),K=n=>()=>{const{start:t,end:e,lineWidth:o}=n,r=Math.min(t.x,e.x)-o/2,s=Math.min(t.y,e.y)-o/2,c=Math.max(t.x,e.x)+o/2,i=Math.max(t.y,e.y)+o/2;return E({at:{x:r,y:s},width:c-r,height:i-s})},wt=n=>{const{start:t,end:e,lineWidth:o}=n,r=Math.hypot(e.x-t.x,e.y-t.y),s=Math.atan2(e.y-t.y,e.x-t.x),c=Math.abs(Math.cos(s))+Math.abs(Math.sin(s)),i=Math.min(50,r*c),l=Math.ceil(r/i),a=(e.x-t.x)/r,u=(e.y-t.y)/r;return d=>I(K(n)(),d)?Array.from({length:l},(f,p)=>{const y=t.x+a*i*p,m=t.y+u*i*p,w=y+a*i,C=m+u*i,v=Math.min(y,w)-o/2,x=Math.min(m,C)-o/2,T=Math.abs(w-y)+o,M=Math.abs(C-m)+o;return E({at:{x:v,y:x},width:T,height:M})}).some(f=>I(f,d)):!1},St=n=>t=>{const{pointA:e,pointB:o,pointC:r,stroke:s}=n,{x:c,y:i}=t,l=.5*(-o.y*r.x+e.y*(-o.x+r.x)+e.x*(o.y-r.y)+o.x*r.y),a=1/(2*l)*(e.y*r.x-e.x*r.y+(r.y-e.y)*c+(e.x-r.x)*i),u=1/(2*l)*(e.x*o.y-e.y*o.x+(e.y-o.y)*c+(o.x-e.x)*i),d=a>0&&u>0&&1-a-u>0;if(!s)return d;const h={start:e,end:o,...s},g={start:o,end:r,...s},f={start:r,end:e,...s},p=z(h,t)||z(g,t)||z(f,t);return d||p},At=n=>()=>{const{pointA:t,pointB:e,pointC:o}=n,r=Math.min(t.x,e.x,o.x),s=Math.min(t.y,e.y,o.y),c=Math.max(t.x,e.x,o.x),i=Math.max(t.y,e.y,o.y);return E({at:{x:r,y:s},width:c-r,height:i-s})},vt=n=>t=>I(At(n)(),t),Pe=n=>{const{start:t,end:e,lineWidth:o,arrowHeadSize:r,arrowHeadShape:s}=n,c=bt(n),{arrowHeadHeight:i,perpLineLength:l}=r(o),a=N({start:t,end:e,lineWidth:o,arrowHeadSize:r}),u=s?s(e,i,l).hitbox:St(a);return d=>c(d)||u(d)},Be=n=>()=>{const{at:t,width:e,height:o}=K(n)(),r={x:t.x,y:t.y},s={x:t.x+e,y:t.y+o},{start:c,end:i,lineWidth:l,arrowHeadSize:a}={...ut,...n},u=N({start:c,end:i,lineWidth:l,arrowHeadSize:a}),d=Math.min(r.x,s.x,u.pointA.x,u.pointB.x,u.pointC.x),h=Math.max(r.x,s.x,u.pointA.x,u.pointB.x,u.pointC.x),g=Math.min(r.y,s.y,u.pointA.y,u.pointB.y,u.pointC.y),f=Math.max(r.y,s.y,u.pointA.y,u.pointB.y,u.pointC.y);return E({at:{x:d,y:g},width:h-d,height:f-g})},Le=n=>{const t=wt(n),{start:e,end:o,lineWidth:r,arrowHeadSize:s}=n,c=N({start:e,end:o,lineWidth:r,arrowHeadSize:s}),i=vt(c);return l=>t(l)||i(l)},Ct=n=>{if(!n.textArea)return;const{textOffsetFromCenter:t,start:e,end:o}=n,r=Ft(e,o),s=t*Math.cos(r),c=t*Math.sin(r),i=(e.x+o.x)/2+s,l=(e.y+o.y)/2+c;return{x:i,y:l}},j=n=>{if(n.lineWidth&&n.lineWidth<0)throw new Error("width must be positive");const t=dt(n),e=Ct(t),o=B(e,t.textArea),r=Ee(t),s=Pe(t),c=Le(t),i=u=>(o==null?void 0:o.textHitbox(u))||s(u),l=Be(t);return L({name:"arrow",draw:u=>{r(u),o==null||o.drawTextArea(u)},drawShape:r,hitbox:i,shapeHitbox:s,efficientHitbox:c,getBoundingBox:l,...o})},F=n=>{if(n.lineWidth&&n.lineWidth<0)throw new Error("lineWidth must be positive");const t=st(n),e=Ct(t),o=B(e,t.textArea),r=bt(t),s=wt(t),c=u=>(o==null?void 0:o.textHitbox(u))||r(u),i=K(t),l=yt(t);return L({name:"line",draw:u=>{l(u),o==null||o.drawTextArea(u)},drawShape:l,hitbox:c,shapeHitbox:r,efficientHitbox:s,getBoundingBox:i,...o})},De=n=>({...W({...ht,...n,width:n.size,height:n.size}),name:"square"}),Ie=n=>{const t=xt(n),e=At(t),o=$(e()),r=B(o,t.textArea),s=St(t),c=vt(t),i=u=>(r==null?void 0:r.textHitbox(u))||s(u),l=mt(t);return L({name:"triangle",draw:u=>{l(u),r==null||r.drawTextArea(u)},drawShape:l,hitbox:i,shapeHitbox:s,efficientHitbox:c,getBoundingBox:e,...r})},Re=n=>{const{spacing:t,at:e,upDistance:o,downDistance:r,rotation:s,lineWidth:c,fillColor:i,arrowHeadShape:l,arrowHeadSize:a,fillGradient:u}=n,d=S({x:e.x,y:e.y-t},e,s),h=S({x:e.x+o,y:e.y-t},e,s),g=S({x:e.x+o,y:e.y+t},e,s),f=S({x:e.x+o-r,y:e.y+t},e,s),p=S({x:e.x+o,y:e.y},e,s);let y=[],m=[],w=[];if(u&&u.length>=2){const x=o+r+Math.PI*t,T=tt(u,o/x),M=tt(u,(x-r)/x);y=[...u.filter(b=>b.offset<=o/x),{offset:1,color:T}],m=[{offset:0,color:T},...u.filter(b=>b.offset>=o/x&&b.offset<=(x-r)/x).map(b=>({offset:(b.offset-o/x)/(Math.PI*t/x),color:b.color})),{offset:1,color:M}],w=[{offset:0,color:M},...u.filter(b=>b.offset>=(x-r)/x).map(b=>({offset:(b.offset-(x-r)/x)/(r/x),color:b.color}))]}const{drawShape:C}=F({start:d,end:h,lineWidth:c,fillColor:i,fillGradient:y}),{drawShape:v}=j({start:g,end:f,lineWidth:c,fillColor:i,arrowHeadSize:a,arrowHeadShape:l,fillGradient:w});return x=>{if(C(x),v(x),x.beginPath(),x.strokeStyle=i,m.length>=2){const T=Math.PI/2+s+.01,M=-Math.PI/2+s-.01,b=p.x+Math.cos(T)*t,Ht=p.y+Math.sin(T)*t,Et=p.x+Math.cos(M)*t,Pt=p.y+Math.sin(M)*t,Q=x.createLinearGradient(Et,Pt,b,Ht);for(const Z of m)Q.addColorStop(Z.offset,Z.color);x.strokeStyle=Q}x.arc(p.x,p.y,t,Math.PI/2+s+.01,-Math.PI/2+s-.01,!0),x.lineWidth=c,x.stroke(),x.closePath()}},We=n=>{const{spacing:t,at:e,downDistance:o,upDistance:r,lineWidth:s,rotation:c}=n,i=S({x:e.x,y:e.y-t},e,c),l=S({x:e.x+r,y:e.y-t},e,c),a=S({x:e.x+r,y:e.y+t},e,c),u=S({x:e.x+r-o,y:e.y+t},e,c),d=S({x:e.x+r,y:e.y},e,c),{hitbox:h}=F({start:i,end:l,lineWidth:s}),{hitbox:g}=j({start:a,end:u,lineWidth:s}),{hitbox:f}=_({at:d,radius:t+s/2});return p=>h(p)||g(p)||f(p)},Mt=n=>()=>{const{spacing:t,at:e,upDistance:o,rotation:r,lineWidth:s}=n,c=S({x:e.x+o,y:e.y},e,r),i=Math.min(e.x,c.x)-s/2-t,l=Math.min(e.y,c.y)-s/2-t,a=Math.max(e.x,c.x)+s/2+t,u=Math.max(e.y,c.y)+s/2+t;return E({at:{x:i,y:l},width:a-i,height:u-l})},_e=n=>t=>I(Mt(n)(),t),Fe=n=>{if(!n.textArea)return;const{at:t,upDistance:e,rotation:o,spacing:r,lineWidth:s}=n,c=S({x:t.x+e+r+s/2,y:t.y},t,o);return{x:c.x+Math.cos(o)*15,y:c.y+Math.sin(o)*15}},Oe=n=>{if(n.downDistance<0)throw new Error("downDistance must be positive");if(n.upDistance<0)throw new Error("upDistance must be positive");const t=lt(n),e=Fe(t),o=B(e,t.textArea),r=Mt(t),s=u=>(o==null?void 0:o.textHitbox(u))||c(u),c=We(t),i=_e(t),l=Re(t);return L({name:"uturn",draw:u=>{l(u),o==null||o.drawTextArea(u)},drawShape:l,hitbox:s,shapeHitbox:c,efficientHitbox:i,getBoundingBox:r,...o})},ze=n=>t=>{const{type:e,fillColor:o,brushWeight:r,points:s}=n;(e==="draw"?()=>{if(s.length===1){_({at:s[0],radius:r/2,fillColor:o}).draw(t);return}t.strokeStyle=o,t.lineCap="round",t.lineJoin="round",t.lineWidth=r,t.beginPath();const[l,...a]=s;t.moveTo(l.x,l.y),a.forEach(({x:u,y:d})=>t.lineTo(u,d)),t.stroke()}:()=>{t.globalCompositeOperation="destination-out",t.lineWidth=Y;for(let l=0;l<s.length-1;l++){const a=s[l],u=s[l+1],d=Math.pow(u.x-a.x,2)+Math.pow(u.y-a.y,2),h=Math.sqrt(d),g=Math.ceil(h/Y);for(let f=0;f<=g;f++){const p=a.x+f/g*(u.x-a.x),y=a.y+f/g*(u.y-a.y);t.beginPath(),t.arc(p,y,Y,0,Math.PI*2),t.fill()}}t.globalCompositeOperation="source-over"})(),t.lineCap="butt",t.lineJoin="miter"},Ue=n=>t=>{const{type:e,points:o,brushWeight:r}=n;if(e==="erase")return!1;const{at:s,width:c,height:i}=J(n)(),{hitbox:l}=W({at:s,width:Math.max(c,r),height:Math.max(i,r)});if(!l(t))return!1;if(o.length===1){const{hitbox:a}=_({at:o[0],radius:r});if(a(t))return!0}for(let a=0;a<o.length-1;a++){const u={start:o[a],end:o[a+1]},{efficientHitbox:d}=F(u);if(d({at:t,width:1,height:1}))return!0}return!1},J=n=>()=>{const{points:t,brushWeight:e}=n;let o=t[0].x,r=t[0].y,s=t[0].x,c=t[0].y;for(const i of t)i.x<o&&(o=i.x),i.y<r&&(r=i.y),i.x>s&&(s=i.x),i.y>c&&(c=i.y);return E({at:{x:o-e/2,y:r-e/2},width:s-o+e,height:c-r+e})},Ve=n=>t=>{if(n.type==="erase")return!1;const{at:e,width:o,height:r}=J(n)(),{points:s,brushWeight:c}=n,{efficientHitbox:i}=W({at:e,width:Math.max(o,c),height:Math.max(r,c)});if(s.length===1){const{efficientHitbox:l}=_({at:s[0],radius:c});return l(t)}if(!i(t))return!1;for(let l=0;l<s.length-1;l++){const a={start:s[l],end:s[l+1]},{efficientHitbox:u}=F(a);if(u(t))return!0}return!1},Y=50,Ge=n=>{if(n.points.length<1)throw new Error("not enough points to draw scribble");if(n.brushWeight&&n.brushWeight<1)throw new Error('brushWeight must be at least "1"');const t=ft(n),e=J(t),o=$(e()),r=B(o,t.textArea),s=Ue(t),c=Ve(t),i=u=>(r==null?void 0:r.textHitbox(u))||s(u),l=ze(t);return L({name:"scribble",drawShape:l,draw:u=>{l(u),r==null||r.drawTextArea(u)},hitbox:i,shapeHitbox:s,efficientHitbox:c,getBoundingBox:e,...r})},Xe=n=>{const{at:t,innerRadius:e,outerRadius:o,points:r=5,rotation:s=0}=n,c=[];for(let i=0;i<r*2;i++){const l=i%2===0?o:e,a=i*Math.PI/r,u=Math.cos(a)*l,d=Math.sin(a)*l,h=S({x:u,y:d},{x:0,y:0},s);c.push({x:h.x+t.x,y:h.y+t.y})}return c},Ye=(n,t)=>{let e=!1;for(let o=0,r=t.length-1;o<t.length;r=o++){const s=t[o].x,c=t[o].y,i=t[r].x,l=t[r].y;c>n.y!=l>n.y&&(l-c!==0?n.x<(i-s)*(n.y-c)/(l-c)+s:n.x<s)&&(e=!e)}return e},qe=n=>t=>{const e=Xe(n);return Ye(t,e)},Tt=n=>()=>{const{at:t,outerRadius:e}=n,o=e*2;return E({at:{x:t.x-e,y:t.y-e},width:o,height:o})},Ne=n=>t=>I(Tt(n)(),t),$e=n=>{const{at:t,fillColor:e,innerRadius:o,outerRadius:r,rotation:s,points:c}=n;return i=>{i.save(),i.beginPath(),i.translate(t.x,t.y),i.rotate(s);for(let l=0;l<c*2;l++){const a=l%2===0?r:o,u=l*Math.PI/c,d=Math.cos(u)*a,h=Math.sin(u)*a;l===0?i.moveTo(d,h):i.lineTo(d,h)}i.closePath(),i.fillStyle=e,i.fill(),i.restore()}},Ke=n=>{const t=pt(n);t.points<3&&console.warn("star must have at least 3 points"),t.innerRadius>=t.outerRadius&&console.warn("inner radius must be less than outer radius"),(t.innerRadius<0||t.outerRadius<0)&&console.warn("radius values must be positive");const e=B(t.at,t.textArea),o=$e(t),r=a=>{o(a),e==null||e.drawTextArea(a)},s=qe(t),c=a=>(e==null?void 0:e.textHitbox(a))||s(a),i=Ne(t),l=Tt(t);return L({name:"star",draw:r,drawShape:o,hitbox:c,shapeHitbox:s,efficientHitbox:i,getBoundingBox:l,...e})},q=new Map,je=async(n,t)=>new Promise(e=>{q.has(n)&&e(q.get(n));const o={image:null,loading:!0,error:!1};q.set(n,o);const r=new Image;r.onload=()=>{var s;o.image=r,o.loading=!1,(s=t.onLoad)==null||s.call(t),e(o)},r.onerror=()=>{var s;o.loading=!1,o.error=!0,(s=t.onLoadError)==null||s.call(t),e(o)},r.src=n}),Je=(n,t,e)=>{const r=-n/2,s=-t/2;for(let c=0;c<Math.ceil(t/10);c++)for(let i=0;i<Math.ceil(n/10);i++)e.fillStyle=(i+c)%2===0?"#FF00DC":"#000000",e.fillRect(r+i*10,s+c*10,10,10)},Qe=n=>{const{src:t,onLoad:e,onLoadError:o,...r}=n,{width:s,height:c,at:i,rotation:l}=r;return async a=>{const{image:u,error:d}=await je(t,{onLoad:e,onLoadError:o});O(r)(a),a.save();const h=i.x+s/2,g=i.y+c/2;a.translate(h,g),l&&a.rotate(l),d&&Je(s,c,a),u&&a.drawImage(u,-s/2,-c/2,s,c),a.restore()}},Ze=n=>{if(n.width<0||n.height<0)throw new Error("width and height must be positive");const t=gt(n),e=B($(t),t.textArea),o=Qe(t),{shapeHitbox:r,efficientHitbox:s,getBoundingBox:c}=W(t);return L({name:"image",draw:async a=>{await o(a),e==null||e.drawTextArea(a)},drawShape:o,hitbox:a=>(e==null?void 0:e.textHitbox(a))||r(a),shapeHitbox:r,efficientHitbox:s,getBoundingBox:c,...e})},A={arrow:j,circle:_,cross:Zt,ellipse:Ot,image:Ze,line:F,rect:W,scribble:Ge,square:De,star:Ke,triangle:Ie,uturn:Oe},ke=500,tn=new Set(["at","start","end","lineWidth","radius","fillColor"]),en=(n,t)=>{const e=new Map,o=new Set,r=new Map,s=(i,l)=>typeof i!=typeof l?!1:typeof i!="object"||i===null||l===null?i===l:JSON.stringify(i)===JSON.stringify(l),c=i=>JSON.parse(JSON.stringify(i));return{captureSchemaState:i=>{i!=null&&i.id&&e.set(i.id,c(i))},applyAutoAnimation:(i,l)=>{if(!o.has(i.id))return;const a=(g,f,p)=>{const y=r.get(`${i.id}-${p}`);y&&y();const{play:m,stop:w}=n({forShapes:[l],durationMs:ke,easing:{[p]:"in-out"},keyframes:[{progress:0,properties:{[p]:c(g)}},{progress:1,properties:{[p]:c(f)}}]});m({shapeId:i.id,runCount:1}),r.set(`${i.id}-${p}`,()=>w({shapeId:i.id}))},u=e.get(i.id);if(!u)return console.warn("no previous schema");const d=t(i.id),h={};for(const[g,f]of Object.entries(u)){if(!tn.has(g))continue;const p=i[g];if(s(f,p))continue;const y=d?d[g]:f;a(y,p,g),h[g]=y}if(Object.keys(h).length!==0)return{...i,...h}},autoAnimate:{start:i=>{o.add(i)},stop:i=>{o.delete(i)},isActive:i=>o.has(i)}}},sn=()=>{const n=new Map,t=new Map,{defineTimeline:e,timelineIdToTimeline:o}=we({play:({shapeId:a,...u})=>{const d={...u,startedAt:Date.now()},h=n.get(a);h?h.push(d):n.set(a,[d])},stop:({shapeId:a,timelineId:u})=>{const d=n.get(a);if(!d)return;const h=d.filter(g=>g.timelineId!==u);if(h.length===0)return n.delete(a);n.set(a,h)},pause:()=>console.warn("not implemented"),resume:()=>console.warn("not implemented")}),r=a=>{const u=n.get(a);if(!u||u.length===0)return;let d=u[0].schema;if(!d)return console.warn("animation set without a schema. this should never happen!");for(const h of u){const g=o.get(h.timelineId);if(!g)throw"animation activated without a timeline!";const f={...g,...h},p=t.get(a);if(!p){console.warn("animation set without shape name mapping. this should never happen!");continue}if(!f.validShapes.has(p)){console.warn("invalid shape name!");continue}if(te(f)>=f.runCount){n.delete(a);continue}const{properties:w}=f,C=ee(f),v=Object.entries(w).reduce((x,T)=>{const[M,b]=T;return M in d&&(x[M]=b(d,C)),x},{});d={...d,...v}}return d},{autoAnimate:s,captureSchemaState:c,applyAutoAnimation:i}=en(e,r),l=(a,u)=>d=>new Proxy(a(d),{get:(h,g)=>{var x;const f=g;if(!kt.has(f))return h[f];const p=n.get(d.id),y=He[u];if(!y)throw`cant find defaults for ${u}`;const m=y(d),w=i(m,u);if(c(m),w)return a(w)[f];if(!p||p.length===0)return h[f];(x=p[0])!=null&&x.schema||(p[0].schema=m),t.get(d.id)||t.set(d.id,u);const v=r(d.id);return v?a(v)[f]:h[f]}});return{shapes:{arrow:l(A.arrow,"arrow"),circle:l(A.circle,"circle"),cross:l(A.cross,"cross"),ellipse:l(A.ellipse,"ellipse"),image:l(A.image,"image"),line:l(A.line,"line"),rect:l(A.rect,"rect"),scribble:l(A.scribble,"scribble"),square:l(A.square,"square"),star:l(A.star,"star"),triangle:l(A.triangle,"triangle"),uturn:l(A.uturn,"uturn")},defineTimeline:e,autoAnimate:s,getAnimatedSchema:r}},nn=()=>{const{class:n}=zt();return H(()=>{if(!n)return[];if(typeof n!="string")throw new Error("class attribute must be a string");return n.split(" ")})},an=Ut({__name:"Button",props:{color:{},textColor:{},disabled:{type:Boolean}},setup(n){const t=n,e=H(()=>{if(!t.color)return;const h=D(t.color);if(!h.isValid())throw new Error("invalid color provided to button");return h}),o=H(()=>{if(!e.value)return;const h=e.value.isDark(),g=e.value.clone();return h?g.lighten(10):g.darken(10)}),r=H(()=>{var h,g;return d.value?(h=o.value)==null?void 0:h.toHexString():(g=e.value)==null?void 0:g.toHexString()}),s=nn(),c=["px-2","py-1","bg-gray-800","text-gray-200","dark:bg-gray-200","dark:text-gray-800","hover:bg-gray-700","dark:hover:bg-gray-300","rounded-md","cursor-pointer","font-bold","transition","duration-100","select-none","flex","justify-center","items-center","text-center"],i=H(()=>$t(c,s.value)),l=H(()=>t.disabled),a=H(()=>{if(t.textColor)return t.textColor;if(e.value)return e.value.isDark()?"white":"black"}),u=H(()=>{const h={pointerEvents:"none",opacity:.5,cursor:"not-allowed"},g={backgroundColor:r.value,color:a.value};return{...t.color?g:{},...l.value?h:{}}}),d=Vt(!1);return(h,g)=>(Nt(),Gt("button",{onMouseenter:g[0]||(g[0]=f=>d.value=!0),onMouseleave:g[1]||(g[1]=f=>d.value=!1),class:Yt(i.value),style:Xt(u.value)},[qt(h.$slots,"default")],38))}});export{ke as A,an as _,nn as a,Zt as c,de as d,ne as g,sn as u};
