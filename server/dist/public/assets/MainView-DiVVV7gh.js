var Q=Object.defineProperty;var Z=(r,e,t)=>e in r?Q(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var C=(r,e,t)=>Z(r,typeof e!="symbol"?e+"":e,t);import{a as M,b as x,g as G,u as ee,_ as te}from"./useGraphWithCanvas-C8vf9Gq4.js";import{d as w,D as _,o as v,w as h,e as m,b as p,u as g,J as $,K as k,B as S,L as re,g as A,y as R,M as F,a as H,c as V,f as oe,F as se,t as J,H as ie,I as ne,E as le}from"./index-DenfF-1e.js";import{_ as W}from"./GHoverInfoTop.vue_vue_type_script_setup_true_lang-WWnO7M1F.js";import{g as ae}from"./getTreeBinaryPos-T5MKRJGv.js";import"./Button.vue_vue_type_script_setup_true_lang-BUksoIV7.js";import"./index-D9D-poV_.js";import"./Icon.vue_vue_type_script_setup_true_lang-D07GTbLO.js";import"./GHoverInfo.vue_vue_type_script_setup_true_lang-BeQGYbBU.js";const ce={persistentStorageKey:"binary-trees",interactive:!1,displayEdgeLabels:!1},ue=w({__name:"CRUDControls",props:{tree:{}},setup(r){const e=r;return(t,s)=>(v(),_(M,{secondary:"",class:"rounded-lg flex gap-2 p-2"},{default:h(()=>[m(x,{onClick:t.tree.balanceTree,disabled:e.tree.isBalanced.value,tertiary:""},{default:h(()=>s[0]||(s[0]=[p(" Balance Tree ")])),_:1,__:[0]},8,["onClick","disabled"]),m(x,{onClick:t.tree.resetTree,disabled:g($).nodes.value.length===0,tertiary:""},{default:h(()=>s[1]||(s[1]=[p(" Reset Tree ")])),_:1,__:[1]},8,["onClick","disabled"])]),_:1}))}}),fe="node-labeller",Y=(r,e,t=fe)=>{const s=l=>typeof e=="function"?e(l):"value"in e?e.value.get(l):e.get(l),{setTheme:i,removeTheme:n}=k(r,t),o=l=>{if(r.focus.isFocused(l.id))return;const u=s(l.id);if(u!==void 0)return u.toString()};return{label:()=>{i("nodeText",o)},unlabel:()=>{n("nodeText")},get:s}},he="node-colorer",K=(r,e,t=he)=>{const s=l=>typeof e=="function"?e(l):"value"in e?e.value.get(l):e.get(l),{setTheme:i,removeTheme:n}=k(r,t),o=l=>{if(!r.focus.isFocused(l.id))return s(l.id)};return{color:()=>{i("nodeBorderColor",o),i("nodeAnchorColor",o)},uncolor:()=>{n("nodeBorderColor"),n("nodeAnchorColor")},get:s}},de=(r,e)=>{const{nodeIdToBalanceFactor:t}=e,s={[-1]:S.YELLOW_500,0:S.GREEN_600,1:S.YELLOW_500},i=S.RED_600,n=b=>s[t.value.get(b)??0]??i,{label:o,unlabel:a}=Y(r,t),{color:c,uncolor:l}=K(r,n);return{activate:()=>{o(),c()},deactivate:()=>{a(),l()}}},{interpolate:ge}=G.utils,ve=r=>{const[e,t]=r.range,s=Array.isArray(r.color)?r.color[0]:r.color,i=Array.isArray(r.color)?r.color[1]:re(r.color).darken(50).toString(),n=ge(s,i);return o=>{const a=(o-e)/(t-e);return a<0?s:a>1?i:n(a)}},me=(r,e)=>{const{nodeIdToHeight:t}=e,s=ve({range:[1,6],color:[S.GREEN_400,S.GREEN_700]}),i=f=>s(t.value.get(f)??0),{label:n,unlabel:o}=Y(r,t),{color:a,uncolor:c}=K(r,i);return{activate:()=>{n(),a()},deactivate:()=>{o(),c()}}},_e=w({__name:"TreeInfoLabels",props:{tree:{}},setup(r){const e=r,{activate:t,deactivate:s}=de($.value,e.tree),{activate:i,deactivate:n}=me($.value,e.tree),o={balanceFactor:"The balance factor of a node is the height of its right subtree minus the height of its left subtree.",height:"The height of a node is the number of edges on the longest path from the node to a leaf."};return(a,c)=>(v(),_(M,{secondary:"",class:"p-2 rounded-lg flex flex-wrap gap-2"},{default:h(()=>[m(W,{onMouseenter:g(t),onMouseleave:g(s),tooltip:o.balanceFactor},{default:h(()=>c[0]||(c[0]=[p(" Balance Factor ")])),_:1,__:[0]},8,["onMouseenter","onMouseleave","tooltip"]),m(W,{onMouseenter:g(i),onMouseleave:g(n),tooltip:o.height},{default:h(()=>c[1]||(c[1]=[p(" Height ")])),_:1,__:[1]},8,["onMouseenter","onMouseleave","tooltip"])]),_:1}))}}),pe=({root:r,treeDepth:e})=>{const t=[];if(!r)return t;let s=[r];for(let i=0;i<=e;i++){const n=[];for(const o of s)t.push(o),n.push(o==null?void 0:o.left),n.push(o==null?void 0:o.right);s=[...n]}return t};class I{constructor(e){C(this,"key");C(this,"left");C(this,"right");C(this,"height");this.key=e,this.left=void 0,this.right=void 0,this.height=1}}const y=r=>r?r.height:0,N=r=>{const e=y(r==null?void 0:r.left),t=y(r==null?void 0:r.right);return e-t};class be{constructor(){C(this,"root");this.root=void 0}reset(){this.root=void 0}getNode(e){let t=this.root;for(;t;){if(e===t.key)return t;e<t.key?t=t.left:t=t.right}}updateHeight(e){e.height=Math.max(y(e.left),y(e.right))+1}removeMin(e){return e.left?(e.left=this.removeMin(e.left),this.updateHeight(e),e):e.right}findMin(e){let t=e;for(;t.left;)t=t.left;return t}remove(e){if(!this.root)return[];const t=[];let s=!1;const i=(n,o,a,c)=>{if(o){if(s||t.push({action:"compare",target:a,treeNodeKey:o.key,treeState:this.toArray()}),a<o.key&&!s)o.left=i(o,o.left,a,!0);else if(a>o.key&&!s)o.right=i(o,o.right,a,!1);else{s=!0;let l;if(!o.left&&!o.right)l=void 0;else if(!o.left)l=o.right;else if(!o.right)l=o.left;else{const u=this.findMin(o.right);l=new I(u.key),l.left=o.left,l.right=this.removeMin(o.right),l.height=o.height}return n?c?n.left=l:n.right=l:this.root=l,t.push({action:"remove",target:a,treeState:this.toArray()}),n?c?n.left=o:n.right=o:this.root=o,l}return o&&(this.updateHeight(o),this.rebalance(n,o,c,t))}};return this.root=i(void 0,this.root,e,!1),t}rebalance(e,t,s,i){const n=N(t);if(n>1&&N(t.left)>=0){const o=this.rotateRight(t);return e?s?e.left=o:e.right=o:this.root=o,i.push({action:"balance",method:"left-left",treeState:this.toArray()}),e?s?e.left=t:e.right=t:this.root=t,o}if(n<-1&&N(t.right)<=0){const o=this.rotateLeft(t);return e?s?e.left=o:e.right=o:this.root=o,i.push({action:"balance",method:"right-right",treeState:this.toArray()}),e?s?e.left=t:e.right=t:this.root=t,o}if(n>1&&N(t.left)<0){t.left=this.rotateLeft(t.left);const o=this.rotateRight(t);return e?s?e.left=o:e.right=o:this.root=o,i.push({action:"balance",method:"left-right",treeState:this.toArray()}),e?s?e.left=t:e.right=t:this.root=t,o}if(n<-1&&N(t.right)>0){t.right=this.rotateRight(t.right);const o=this.rotateLeft(t);return e?s?e.left=o:e.right=o:this.root=o,i.push({action:"balance",method:"right-left",treeState:this.toArray()}),e?s?e.left=t:e.right=t:this.root=t,o}return t}balance(){const e=[],t=(s,i,n)=>{if(i)return i.left=t(i,i.left,!0),i.right=t(i,i.right,!1),this.updateHeight(i),this.rebalance(s,i,n,e)};return this.root=t(void 0,this.root,!1),e}toArray(){return pe({root:this.root,treeDepth:y(this.root)}).map(e=>e==null?void 0:e.key)}rotateRight(e){const t=e.left,s=t.right;return t.right=e,e.left=s,this.updateHeight(e),this.updateHeight(t),t}rotateLeft(e){const t=e.right,s=t.left;return t.left=e,e.right=s,this.updateHeight(e),this.updateHeight(t),t}insert(e,t=!0){if(!this.root)return this.root=new I(e),[{action:"insert",target:e,treeState:this.toArray()}];const s=[];let i=!1;const n=(o,a,c,l)=>{if(!a){const u=new I(c);return i=!0,u}if(s.push({action:"compare",treeNodeKey:a.key,target:c,treeState:this.toArray()}),c<a.key)a.left=n(a,a.left,c,!0),i&&(s.push({action:"insert",target:c,treeState:this.toArray()}),i=!1);else if(c>a.key)a.right=n(a,a.right,c,!1),i&&(s.push({action:"insert",target:c,treeState:this.toArray()}),i=!1);else return a;return this.updateHeight(a),t?this.rebalance(o,a,l,s):a};return this.root=n(void 0,this.root,e,!1),s}}const Te=S.AMBER_600,Ne=r=>{const{setTheme:e,removeAllThemes:t}=k(r,"tree"),s=A(),i=a=>{if(s.value&&!r.focus.isFocused(a.id)&&a.id===s.value)return Te};return{activate:a=>{a&&(s.value=a),e("nodeBorderColor",i),e("nodeAnchorColor",i)},deactivate:()=>{s.value=void 0,t()},targetNodeId:s}},O=(r,e)=>({from:r.toString(),to:e.toString(),id:`${r}-${e}`,label:"1"}),Se=r=>{const e=[];for(let t=0;t<r.length;t++){const s=r[t];if(s===void 0)continue;const i=r[2*t+1],n=r[2*t+2];i!==void 0&&e.push(O(s,i)),n!==void 0&&e.push(O(s,n))}return e},ye=async(r,e,t,s)=>{const i=Se(e),n=r.edges.value.filter(l=>!i.some(u=>u.id===l.id)),o=r.nodes.value.filter(l=>!e.includes(parseInt(l.id)));if(await Promise.all(o.map(l=>r.removeNode(l.id,{animate:!0}))),!t)return;const c=ae({rootCoordinate:s,xOffset:{2:175,3:135,4:100}[t.height]??80,yOffset:200,treeDepth:t.height});await Promise.all(e.map((l,u)=>{if(!(l===void 0||r.getNode(l.toString())))return r.addNode({id:l.toString(),label:l.toString(),...c[u]},{animate:!0,focus:!1})})),await Promise.all(n.map(l=>r.removeEdge(l.id,{animate:!0}))),await new Promise(l=>setTimeout(l,500)),await Promise.all(e.map((l,u)=>{if(l===void 0)return;const f=r.getNode(l.toString());f&&(f.x===c[u].x&&f.y===c[u].y||r.animate.node({nodeId:f.id,endCoords:c[u],durationMs:750}))}));for(const l of i)await r.addEdge(l,{animate:!0})},Ae={x:window.innerWidth/2,y:window.innerHeight/2},{activeSim:U}=F,Ce=r=>({graph:e,tree:t,trace:s})=>{const{targetNodeId:i,activate:n}=Ne(e);n();const o=A(0),a=async()=>{const f=s[o.value];if(f!==void 0){if(i.value=void 0,f.action==="compare"){const{treeNodeKey:b}=f;i.value=b.toString()}if(f.action==="insert"||f.action==="remove"){const{target:b}=f;i.value=b.toString()}await ye(e,f.treeState,t.root,Ae),r()}};a();const c=async()=>{++o.value,await a()},l=async()=>{--o.value,await a()},u=async()=>{o.value!==s.length-1&&(o.value=s.length-1,a()),U.value=void 0,i.value=void 0};U.value={step:R(()=>o.value),next:c,prev:l,exit:u,trace:R(()=>s)}},xe=r=>{const e=A([]),t=A([]);return{undo:()=>{if(console.log(e.value),e.value.length===0)return;const n=e.value.pop();n&&(t.value.push(n),r.load(n))},redo:()=>{if(t.value.length===0)return;const n=t.value.pop();n&&(e.value.push(n),r.load(n))},undoStack:e,redoStack:t}},we=(r,e)=>{if(e.reset(),r.nodes.value.length===0)return;const{getInboundEdges:t,getChildrenOfNode:s}=r.helpers,i=r.nodes.value.find(o=>t(o.id).length===0);if(!i)return console.warn("could not parse tree from graph"),r.reset();const n=[i];for(;n.length>0;){const o=n.shift();o&&(e.insert(Number(o.label),!1),n.push(...s(o.id)))}},Ee=r=>{const e=new be,{undoStack:t,undo:s,redo:i}=xe(r),n=d=>r.nodes.value.reduce((L,P)=>{const D=e.getNode(Number(P.id));return D&&L.set(P.id,d(D)),L},new Map),o=A(n(N)),a=A(n(y)),c=()=>{o.value=n(N),a.value=n(y)},l=Ce(c),u=()=>{const d=JSON.parse(JSON.stringify({nodes:r.nodes.value,edges:r.edges.value}));t.value.push(d)},f=async d=>{u();const T=e.insert(d);l({graph:r,tree:e,trace:T})},b=async()=>{u();const d=e.balance();l({graph:r,tree:e,trace:d}),t.value.push({nodes:r.nodes.value,edges:r.edges.value})},X=async d=>{u();const T=e.remove(d);l({graph:r,tree:e,trace:T}),t.value.push({nodes:r.nodes.value,edges:r.edges.value})},j=()=>{u(),e.reset(),r.reset(),c()},q=()=>{const{root:d}=e;if(d)return r.getNode(d.toString())},z=R(()=>Array.from(o.value.values()).every(T=>T>=-1&&T<=1));return r.subscribe("onGraphLoaded",()=>{we(r,e),c()}),{tree:e,insertNode:f,removeNode:X,balanceTree:b,resetTree:j,nodeIdToBalanceFactor:o,isBalanced:z,nodeIdToHeight:a,getRoot:q,undo:s,redo:i}},He={class:"flex gap-2 flex-col"},Re=w({__name:"AddNodePanel",props:{tree:{}},setup(r){const e=r,t=()=>{const i=e.tree.tree.toArray().filter(l=>l!==void 0);if(i.length===0)return[1,2,3,4,5];const n=Math.min(...i),o=Math.max(...i),a=[];for(let l=n-10;l<o+10;l++)a.push(l);const c=a.filter(l=>i.every(u=>l!==u));return G.utils.shuffle(c).slice(0,5)},s=A([]);return setTimeout(()=>s.value=t(),5),(i,n)=>(v(),_(M,{class:"p-2 rounded-xl"},{default:h(()=>[H("div",He,[(v(!0),V(se,null,oe(s.value,o=>(v(),_(x,{key:o,onClick:a=>e.tree.insertNode(o),secondary:"",class:"rounded-full w-10 h-10"},{default:h(()=>[p(J(o),1)]),_:2},1032,["onClick"]))),128))])]),_:1}))}}),{activeSim:B}=F,E={balance:r=>{const e="Tree Unbalanced! ";if(r.method==="left-left")return e+"Preforming A Left-Left Balance";if(r.method==="left-right")return e+"Preforming A Left-Right Balance";if(r.method==="right-left")return e+"Preforming A Right-Left Balance";if(r.method==="right-right")return e+"Preforming A Right-Right Balance";throw"invalid balance method"},compare:r=>{var s,i;const{target:e,treeNodeKey:t}=r;return e>t?`${e} Is Greater Than ${t}, So We Go Right`:e<t?`${e} Is Less Than ${t}, So We Go Left`:((s=B.value)==null?void 0:s.step)===((i=B.value)==null?void 0:i.trace.value.length)?"We Have A Duplicate, So We End Here":`Found ${e}`},insert:r=>`At A Leaf Position, So We Insert ${r.target}`,remove:r=>`Removing ${r.target}`},Be=r=>{if(r.action==="balance")return E.balance(r);if(r.action==="compare")return E.compare(r);if(r.action==="insert")return E.insert(r);if(r.action==="remove")return E.remove(r)},Me=()=>R(()=>{if(!B.value)return;const{trace:r,step:e}=B.value,t=r.value[e.value];if(t)return Be(t)}),Le={class:""},Ie={class:"mb-2 font-bold text-2xl"},$e=w({__name:"TreeSimMenu",props:{controls:{}},setup(r){const e=r,t=Me();return(s,i)=>(v(),V("div",Le,[H("div",null,[H("h1",Ie,J(g(t)??"N/A"),1)]),H("div",null,[m(M,{secondary:"",class:"rounded-lg flex gap-2 p-2"},{default:h(()=>[m(x,{onClick:e.controls.prev,tertiary:"",disabled:e.controls.step.value===0},{default:h(()=>i[0]||(i[0]=[p(" 👈 prev ")])),_:1,__:[0]},8,["onClick","disabled"]),m(x,{onClick:e.controls.next,tertiary:"",disabled:e.controls.trace.value.length-1===e.controls.step.value},{default:h(()=>i[1]||(i[1]=[p(" next 👉 ")])),_:1,__:[1]},8,["onClick","disabled"]),m(x,{onClick:e.controls.exit,tertiary:""},{default:h(()=>i[2]||(i[2]=[p(" Done ")])),_:1,__:[2]},8,["onClick"])]),_:1})])]))}}),Je=w({__name:"MainView",setup(r){const{activeSim:e}=F,t=ee(ce),{graph:s}=t,i=Ee(s);return s.settings.value.shortcutDelete=()=>{const{focusedNodes:n}=s.focus;n.value.length===1&&i.removeNode(Number(n.value[0].label)),n.value.length===s.nodes.value.length&&i.resetTree(),s.focus.reset()},s.settings.value.shortcutUndo=()=>{i.undo()},s.settings.value.shortcutRedo=()=>i.redo(),(n,o)=>(v(),_(te,ie(ne(g(t))),{"top-center":h(()=>[m(_e,{tree:g(i)},null,8,["tree"])]),"center-left":h(()=>[g(e)?le("",!0):(v(),_(Re,{key:0,tree:g(i)},null,8,["tree"]))]),"bottom-center":h(()=>[g(e)?(v(),_($e,{key:1,controls:g(e)},null,8,["controls"])):(v(),_(ue,{key:0,tree:g(i)},null,8,["tree"]))]),_:1},16))}});export{Je as default};
