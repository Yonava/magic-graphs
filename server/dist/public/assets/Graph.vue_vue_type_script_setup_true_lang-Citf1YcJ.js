import{ax as Ee,ay as Ne,az as xe,U as Ae,z as V,B as J,aA as Q,aB as fe,aC as we,aa as se,H as U,g as C,y as he,aD as Ce,a8 as Z,aE as ve,aF as Me,an as Ie,ao as De,aG as Be,aH as pe,u as me,A as $,aq as ke,ar as Re,aI as Fe,aJ as Oe,aK as _e,aL as Le,aM as Ge,aN as Pe,e as Ue,o as We,N as He}from"./index-mwhRdajb.js";import{c as be,a as qe,u as Ke,l as ye,b as ze,g as Se,r as re,s as j,_ as Ve}from"./ResponsiveCanvas.vue_vue_type_script_setup_true_lang-DHetaqMU.js";const ee={light:Ee,dark:Ne,girl:xe},Je=(s,t)=>{const e=Ae();V(e,()=>{const a=s.theme.value;e.value?Object.assign(a,{...ee.dark,...t}):Object.assign(a,{...ee.light,...t})},{immediate:!0})},Ye=(s,t)=>{const e=t("nodeColor",s),a=t("nodeBorderColor",s),o=t("nodeSize",s),n=t("nodeBorderWidth",s),y=t("nodeText",s),l=t("nodeTextSize",s),m=t("nodeTextColor",s),h=t("nodeShape",s),E=be({at:{x:s.x,y:s.y},radius:o,color:e,stroke:{color:a,width:n},textArea:{text:{content:y,fontSize:l,fontWeight:"bold",color:m},color:J.TRANSPARENT}}),g=qe({at:{x:s.x-o,y:s.y-o},size:o*2,color:e,stroke:{color:a,width:n},textArea:{text:{content:y,fontSize:l,fontWeight:"bold",color:m},color:J.TRANSPARENT}});return{shape:h==="circle"?E:g,id:s.id,graphType:"node"}},je=1.618,ae=2,Ze=(s,t)=>{const{displayEdgeLabels:e,isGraphDirected:a}=t.settings.value,[o,n]=Q(s.id,t),l=fe(o.id,n.id,t).length>1,m=n===o,h=t.getTheme("nodeBorderWidth",o),E=t.getTheme("nodeBorderWidth",n),g=t.getTheme("nodeSize",o),S=t.getTheme("nodeSize",n),v=Math.atan2(n.y-o.y,n.x-o.x),i=E/2+ae,c={x:(S+i)*Math.cos(v),y:(S+i)*Math.sin(v)},b={x:o.x,y:o.y},d={x:n.x-(a?c.x:0),y:n.y-(a?c.y:0)},N=t.getTheme("edgeWidth",s),r=N*1.2;l&&(b.x+=Math.cos(v+Math.PI/2)*r,b.y+=Math.sin(v+Math.PI/2)*r,d.x+=Math.cos(v+Math.PI/2)*r,d.y+=Math.sin(v+Math.PI/2)*r);const f=we(b,t.edges.value.filter(R=>(R.from===o.id||R.to===n.id)&&R.from!==R.to).map(R=>{const[G,q]=Q(R.id,t);return o.id===G.id?{x:q.x,y:q.y}:{x:G.x,y:G.y}}).filter((R,G,q)=>G===q.findIndex(Y=>Y.x===R.x&&Y.y===R.y))),u=t.getTheme("edgeColor",s),p=t.getTheme("edgeTextColor",s),A=t.getTheme("graphBgColor"),D=t.getTheme("edgeText",s),w=t.getTheme("edgeTextSize",s),B=t.getTheme("edgeTextFontWeight",s),M=e?{color:A,activeColor:A,text:{content:D,color:p,fontSize:w,fontWeight:B}}:void 0,I=(g+h)*je,F=I-(g+h/2)-ae;if(m)return{shape:Ke({spacing:N*1.2,at:{x:o.x,y:o.y},upDistance:I,downDistance:F,rotation:f,lineWidth:N,color:u,textArea:M}),id:s.id,graphType:"edge"};const _=g+h/2+S+E/2,L=(o.x-n.x)**2+(o.y-n.y)**2;if(_**2>L)return;if(!a)return{shape:ye({start:b,end:d,width:N,color:u,textArea:M}),id:s.id,graphType:"edge"};const P=g>=50?.9:g>=25?1:1.3;return{shape:ze({start:b,end:d,width:N,textOffsetFromCenter:g**P,color:u,textArea:M}),id:s.id,graphType:"edge"}},Xe=()=>({primaryColor:[],secondaryColor:[],tertiaryColor:[],primaryTextColor:[],secondaryTextColor:[],tertiaryTextColor:[],nodeSize:[],nodeBorderWidth:[],nodeColor:[],nodeBorderColor:[],nodeFocusColor:[],nodeFocusBorderColor:[],nodeText:[],nodeFocusTextColor:[],nodeTextSize:[],nodeTextColor:[],nodeShape:[],edgeColor:[],edgeWidth:[],edgeText:[],edgeTextSize:[],edgeTextColor:[],edgeFocusTextColor:[],edgeTextFontWeight:[],edgeFocusColor:[],graphBgColor:[],graphBgPatternColor:[],nodeAnchorRadius:[],nodeAnchorColor:[],nodeAnchorColorWhenParentFocused:[],linkPreviewColor:[],linkPreviewWidth:[],marqueeSelectionBoxColor:[],marqueeSelectionBoxBorderColor:[],marqueeEncapsulatedNodeBoxColor:[],marqueeEncapsulatedNodeBoxBorderColor:[]}),Qe=s=>Object.prototype.toString.call(s)==="[object Object]",te=(s,t)=>{const e={};if(!s)return t;if(!t)return null;const a=Object.keys(s),o=Object.keys(t);for(const n of o)a.includes(n)||(e[n]=t[n]);for(const n of a){if(Qe(s[n])){const y=te(s[n],t[n]);y&&(e[n]=y);continue}if(Array.isArray(s[n])){JSON.stringify(s[n])!==JSON.stringify(t[n])&&(e[n]=t[n]);continue}else s[n]!==t[n]&&(e[n]=t[n])}return Object.keys(e).length?e:null},K=s=>{const t={...s};for(const e in t)typeof t[e]=="object"&&(t[e]=K(t[e]));return t},$e=s=>({subscribe:(t,e)=>s[t].add(e),unsubscribe:(t,e)=>s[t].delete(e),emit:(t,...e)=>{for(const a of s[t])a(...e)}}),et=()=>({onStructureChange:new Set,onNodeAdded:new Set,onBulkNodeAdded:new Set,onNodeRemoved:new Set,onBulkNodeRemoved:new Set,onNodeMoved:new Set,onBulkNodeMoved:new Set,onEdgeAdded:new Set,onBulkEdgeAdded:new Set,onEdgeRemoved:new Set,onBulkEdgeRemoved:new Set,onEdgeLabelChange:new Set,onRepaint:new Set,onNodeHoverChange:new Set,onGraphReset:new Set,onClick:new Set,onMouseDown:new Set,onMouseUp:new Set,onMouseMove:new Set,onDblClick:new Set,onContextMenu:new Set,onKeyDown:new Set,onKeyUp:new Set,onThemeChange:new Set,onSettingsChange:new Set,onUndo:new Set,onRedo:new Set,onFocusChange:new Set,onNodeDragStart:new Set,onNodeDrop:new Set,onNodeAnchorDragStart:new Set,onNodeAnchorDrop:new Set,onGroupDragStart:new Set,onGroupDrop:new Set}),ue=s=>s==null,tt=s=>{const t=s.trim().split("/").filter(Boolean);if(t.length!==2)return!1;const[e,a]=t.map(Number);return!(ue(e)||ue(a))},ot=s=>{if(!tt(s))return;const t=s.split("/"),[e,a]=t.map(Number);return e/a},nt={displayEdgeLabels:!0,edgeLabelsEditable:!0,edgeInputToLabel:s=>{var a;const t=s.trim();if(!t)return;const e=(a=ot(t))==null?void 0:a.toFixed(2);return e==="Infinity"?"∞":e==="-Infinity"?"-∞":e===void 0&&isNaN(Number(t))?void 0:e??t},newNodeLabelGetter:null,isGraphDirected:!0},st={focusable:!0,focusBlacklist:[]},rt={draggable:!0},at={nodeAnchors:!0},ut={marquee:!0,marqueeSelectableGraphTypes:["node","edge"]},it={userEditable:!0,userAddedEdgeLabel:"1",userAddedEdgeRuleNoSelfLoops:!1,userAddedEdgeRuleOneEdgePerPath:!1},ct={persistent:!0,persistentStorageKey:"graph",persistentBlacklist:new Set},dt={},lt={...nt,...st,...rt,...at,...ut,...it,...ct,...dt},gt=(s,t)=>(e,...a)=>{const o=t[e].findLast(y=>{const l=y.value;return se(l,...a)!==void 0}),n=(o==null?void 0:o.value)??s.value[e];if(!n)throw new Error(`Theme property "${e}" not found`);return se(n,...a)},ft=(s,t)=>{const e=U(()=>{const o=new Map;for(const n of s.value)o.set(n.id,n);return o}),a=U(()=>{const o=new Map;for(const n of t.value)o.set(n.id,n);return o});return{nodeIdToNodeMap:e,edgeIdToEdgeMap:a}},ht=({canvas:s,emit:t})=>{const e=C([]),a=[],o=()=>{var S,v,i,c;if(!s.value)return;const l=s.value.getContext("2d");if(!l)return;l.clearRect(0,0,s.value.width,s.value.height);const m=a.reduce((b,d)=>d(b),[]);e.value=[...m.sort((b,d)=>b.priority-d.priority)];const h=e.value.findLastIndex(b=>b.graphType==="edge"),E=e.value.slice(0,h+1),g=e.value.slice(h+1);for(const b of E)b.shape.drawShape(l);for(const b of E)(v=(S=b.shape).drawTextAreaMatte)==null||v.call(S,l);for(const b of E)(c=(i=b.shape).drawText)==null||c.call(i,l);for(const b of g)b.shape.draw(l);t("onRepaint",l,"loop")},n=setInterval(o,1e3/60);return he(()=>{clearInterval(n)}),setTimeout(o,1e3),{aggregator:e,updateAggregator:a,getSchemaItemsByCoordinates:l=>e.value.sort((m,h)=>m.priority-h.priority).filter(m=>{var h,E;return m.shape.shapeHitbox(l)||((E=(h=m.shape).textHitbox)==null?void 0:E.call(h,l))})}},vt={broadcast:!0,focus:!0,history:!0},pt={broadcast:!0,focus:!1,history:!0},ie={broadcast:!0,history:!0},ce={broadcast:!0,focus:!1,history:!0},de={broadcast:!0,history:!0},mt={broadcast:!0},bt={label:""},yt=({nodes:s,edges:t,nodeMap:e,edgeMap:a,emit:o,settings:n})=>{const y=d=>e.value.get(d),l=d=>a.value.get(d),m=(d,N={})=>{if(d!=null&&d.id&&y(d.id)){console.warn("prevented adding a node with an existing id, this shouldn't happen");return}const r={...vt,...N},f=n.value.newNodeLabelGetter??Ce({nodes:s}),u={id:d.id??Z(),label:d.label??f(),x:d.x??0,y:d.y??0};return s.value.push(u),o("onNodeAdded",u,r),o("onStructureChange",s.value,t.value),u},h=(d,N={})=>{if(d.length===0)return;const r={...pt,...N},f=[];for(const u of d){const p=m(u,{focus:!1,broadcast:!1,history:!1});p&&f.push(p)}f.length!==0&&o("onBulkNodeAdded",f,r)},E=(d,N={})=>{const r={...ce,...N},{isGraphDirected:f}=n.value,[u,p]=[y(d.from),y(d.to)];if(!u||!p)return;if(f){if(t.value.find(w=>w.from===d.from&&w.to===d.to))return}else if(t.value.find(w=>w.from===d.from&&w.to===d.to||w.from===d.to&&w.to===d.from))return;const A={...bt,id:Z(),...d};return t.value.push(A),o("onEdgeAdded",A,r),o("onStructureChange",s.value,t.value),A},g=(d,N={})=>{if(d.length===0)return;const r={...ce,...N},f=[];for(const u of d){const p=E(u,{broadcast:!1,history:!1});p&&f.push(p)}f.length!==0&&o("onBulkEdgeAdded",f,r)},S=(d,N,r={})=>{const f=y(d);if(!f)return;const u={...mt,...r};f.x=N.x,f.y=N.y,o("onNodeMoved",f,u)},v=(d,N={})=>{const r=y(d);if(!r)return;const f={...ie,...N},p=ve(r.id,{edges:t,getEdge:l,settings:n}).map(A=>c(A.id,{broadcast:!1,history:!1})).filter(Boolean);return s.value=s.value.filter(A=>A.id!==r.id),o("onNodeRemoved",r,p,f),o("onStructureChange",s.value,t.value),[r,p]},i=(d,N={})=>{if(d.length===0)return;const r={...ie,...N},f=[],u=[];for(const p of d){const A=v(p,{broadcast:!1,history:!1});if(!A)continue;const[D,w]=A;f.push(D),u.push(...w)}f.length!==0&&o("onBulkNodeRemoved",f,u,r)},c=(d,N={})=>{const r=l(d);if(!r)return;const f={...de,...N};return t.value=t.value.filter(u=>u.id!==r.id),o("onEdgeRemoved",r,f),o("onStructureChange",s.value,t.value),r};return{getNode:y,getEdge:l,addNode:m,addEdge:E,moveNode:S,removeNode:v,removeEdge:c,bulkAddNode:h,bulkRemoveNode:i,bulkAddEdge:g,bulkRemoveEdge:(d,N={})=>{if(d.length===0)return;const r={...de,...N},f=[];for(const u of d){const p=c(u,{broadcast:!1,history:!1});p&&f.push(p)}if(f.length!==0)return o("onBulkEdgeRemoved",f,r),f}}},St=({subscribe:s,canvas:t,graphAtMousePosition:e})=>{const a=C(!1),o=C(!1),n=C({node:"grab",edge:"pointer","node-anchor":"grab","encapsulated-node-box":"move"}),y=C(),l=U(()=>!!y.value),m=S=>{y.value=S},h=()=>{y.value=void 0},E=S=>{var i;if(!S)return"default";if(l.value)return((i=y.value)==null?void 0:i.call(y,S))??!1?"pointer":"default";const v=n.value[S.graphType]??"default";return v==="grab"&&a.value?"grabbing":v},g=({items:S})=>{if(!t.value||o.value)return;const v=S.at(-1);t.value.style.cursor=E(v)};return s("onMouseDown",S=>{a.value=!0,g(S)}),s("onMouseUp",S=>{a.value=!1,g(S)}),s("onMouseMove",g),V(n,()=>{g({items:e.value.items})},{deep:!0}),{graphToCursorMap:n,activateCursorSelectMode:m,deactivateCursorSelectMode:h,graphCursorDisabled:o}},Tt=(s,t={})=>{const e=C({...ee.light,...t.theme}),a=Xe(),o=gt(e,a),n=C({...lt,...t.settings}),y=et(),{subscribe:l,unsubscribe:m,emit:h}=$e(y),E=C(!0);Me(s,()=>{E.value=!1}),l("onMouseDown",()=>{E.value=!0});const g=C([]),S=C([]),v=C({coords:{x:0,y:0},items:[]}),i=St({canvas:s,subscribe:l,graphAtMousePosition:v}),c=x=>{const k=Se(s),O=Be(x,k);v.value={coords:O,items:u(O)}},b=x=>({...v.value,event:x}),d={click:x=>h("onClick",b(x)),mousemove:x=>h("onMouseMove",b(x)),mousedown:x=>h("onMouseDown",b(x)),mouseup:x=>h("onMouseUp",b(x)),dblclick:x=>h("onDblClick",b(x)),contextmenu:x=>h("onContextMenu",b(x))},N={keydown:x=>h("onKeyDown",x),keyup:x=>h("onKeyUp",x)},{aggregator:r,updateAggregator:f,getSchemaItemsByCoordinates:u}=ht({canvas:s,emit:h}),p=x=>{const k={edges:S,getNode:w,getEdge:B,getTheme:o,settings:n},O=S.value.map(W=>Ze(W,k)).filter(Boolean).map((W,X)=>({...W,priority:X*10})),Te=g.value.map(W=>Ye(W,o)).filter(Boolean).map((W,X)=>({...W,priority:X*10+1e3}));return x.push(...O),x.push(...Te),x};f.push(p),Ie(()=>{if(!s.value)throw new Error("canvas element not found");s.value.addEventListener("mousemove",c);for(const[x,k]of Object.entries(d))s.value.addEventListener(x,k);for(const[x,k]of Object.entries(N))document.addEventListener(x,k)}),De(()=>{if(!s.value)throw new Error("Canvas element not found");s.value.removeEventListener("mousemove",c);for(const[x,k]of Object.entries(d))s.value.removeEventListener(x,k);for(const[x,k]of Object.entries(N))document.removeEventListener(x,k)});const{nodeIdToNodeMap:A,edgeIdToEdgeMap:D}=ft(g,S),{getNode:w,getEdge:B,addNode:T,addEdge:M,moveNode:I,removeNode:F,removeEdge:_,bulkAddNode:L,bulkRemoveNode:H,bulkAddEdge:P,bulkRemoveEdge:z}=yt({nodes:g,edges:S,nodeMap:A,edgeMap:D,emit:h,settings:n}),R=(x,k)=>{const O=u({x,y:k}).pop();if(O&&O.graphType==="node")return w(O.id)};let G;l("onMouseMove",({items:x})=>{const k=x.at(-1);if(!k||k.graphType!=="node")return;const O=w(k.id);O!==G&&(h("onNodeHoverChange",O,G),G=O)});const q=x=>(G&&pe(G.id,x),x);f.push(q);const Y=()=>{g.value=[],S.value=[],h("onGraphReset")};l("onGraphReset",()=>h("onStructureChange",g.value,S.value));const oe=C(K(e.value));V(e,x=>{const k=te(oe.value,e.value);k&&(oe.value=K(x),h("onThemeChange",k))},{deep:!0});const ne=C(K(n.value));return V(n,x=>{const k=te(ne.value,x);k&&(ne.value=K(n.value),h("onSettingsChange",k))},{deep:!0}),{nodes:g,edges:S,getNode:w,getEdge:B,addNode:T,addEdge:M,moveNode:I,removeNode:F,removeEdge:_,bulkAddNode:L,bulkRemoveNode:H,bulkAddEdge:P,bulkRemoveEdge:z,getSchemaItemsByCoordinates:u,getNodeByCoordinates:R,eventBus:y,subscribe:l,unsubscribe:m,emit:h,updateAggregator:f,aggregator:r,theme:e,getTheme:o,themeMap:a,settings:n,reset:Y,canvas:s,canvasFocused:E,graphAtMousePosition:v,updateGraphAtMousePosition:c,...i}},Et={focus:!0},Nt={focus:!0},le=100,ge=3,xt=(s,t={})=>{const e=Tt(s,t),a=C([]),o=C([]),n=i=>{a.value.push(i),a.value.length>le&&a.value.shift()},y=i=>{o.value.push(i),o.value.length>le&&o.value.shift()};e.subscribe("onNodeAdded",(i,{history:c})=>{c&&n({action:"add",affectedItems:[{graphType:"node",data:i}]})}),e.subscribe("onBulkNodeAdded",(i,{history:c})=>{c&&n({action:"add",affectedItems:i.map(b=>({graphType:"node",data:b}))})}),e.subscribe("onNodeRemoved",(i,c,{history:b})=>{if(!b)return;const d=c.map(N=>({graphType:"edge",data:N}));n({action:"remove",affectedItems:[{graphType:"node",data:i},...d]})}),e.subscribe("onBulkNodeRemoved",(i,c,{history:b})=>{if(!b)return;const d=i.map(r=>({graphType:"node",data:r})),N=c.map(r=>({graphType:"edge",data:r}));n({action:"remove",affectedItems:[...d,...N]})}),e.subscribe("onEdgeAdded",(i,{history:c})=>{c&&n({action:"add",affectedItems:[{graphType:"edge",data:i}]})}),e.subscribe("onBulkEdgeAdded",(i,{history:c})=>{c&&n({action:"add",affectedItems:i.map(b=>({graphType:"edge",data:b}))})}),e.subscribe("onEdgeRemoved",(i,{history:c})=>{c&&n({action:"remove",affectedItems:[{graphType:"edge",data:i}]})}),e.subscribe("onBulkEdgeRemoved",(i,{history:c})=>{c&&n({action:"remove",affectedItems:i.map(b=>({graphType:"edge",data:b}))})});const l=C();e.subscribe("onGroupDragStart",(i,c)=>{l.value={startingCoordinates:c,nodes:i}}),e.subscribe("onGroupDrop",(i,c)=>{if(!l.value)throw new Error("dropped a group we didn't know was being dragged");if(l.value.nodes.length!==i.length)throw new Error("group size mismatch");const b=l.value.startingCoordinates.y-c.y,d=l.value.startingCoordinates.x-c.x;Math.sqrt(b**2+d**2)<ge||n({action:"move",affectedItems:l.value.nodes.map(r=>({graphType:"node",data:{id:r.id,from:{x:r.x+d,y:r.y+b},to:{x:r.x,y:r.y}}}))})});const m=C();e.subscribe("onNodeDragStart",i=>{m.value={id:i.id,from:{x:i.x,y:i.y},to:{x:i.x,y:i.y}}}),e.subscribe("onNodeDrop",i=>{if(!m.value)throw new Error("dropped a node we didn't know was being dragged");if(m.value.id!==i.id)throw new Error("node ID mismatch");m.value.to={x:i.x,y:i.y};const c=m.value.from.y-m.value.to.y,b=m.value.from.x-m.value.to.x;Math.sqrt(c**2+b**2)<ge||n({action:"move",affectedItems:[{graphType:"node",data:m.value}]})});const h=(i={})=>{const c=a.value.pop();if(c)return y(c),g(c),e.emit("onUndo",c,{...Et,...i}),c},E=(i={})=>{const c=o.value.pop();if(c)return n(c),S(c),e.emit("onRedo",c,{...Nt,...i}),c},g=i=>{if(i.action==="add")for(const c of i.affectedItems)c.graphType==="node"?e.removeNode(c.data.id,{history:!1}):c.graphType==="edge"&&e.removeEdge(c.data.id,{history:!1});else if(i.action==="remove")for(const c of i.affectedItems)c.graphType==="node"?e.addNode(c.data,{history:!1,focus:!1}):c.graphType==="edge"&&e.addEdge(c.data,{history:!1,focus:!1});else if(i.action==="move"){for(const c of i.affectedItems)if(c.graphType==="node"){const{from:b,id:d}=c.data;e.moveNode(d,{x:b.x,y:b.y})}}},S=i=>{if(i.action==="add")for(const c of i.affectedItems)c.graphType==="node"?e.addNode(c.data,{history:!1,focus:!1}):c.graphType==="edge"&&e.addEdge(c.data,{history:!1,focus:!1});else if(i.action==="remove")for(const c of i.affectedItems)c.graphType==="node"?e.removeNode(c.data.id,{history:!1}):c.graphType==="edge"&&e.removeEdge(c.data.id,{history:!1});else if(i.action==="move"){for(const c of i.affectedItems)if(c.graphType==="node"){const{to:b,id:d}=c.data;e.moveNode(d,{x:b.x,y:b.y})}}},v=()=>{a.value=[],o.value=[]};return{...e,undo:h,redo:E,canUndo:U(()=>a.value.length>0),canRedo:U(()=>o.value.length>0),undoStack:a,redoStack:o,addToUndoStack:n,addToRedoStack:y,clearHistory:v}},At=["node","edge"],wt="use-focus-graph",Ct=(s,t={})=>{const e=xt(s,t),{setTheme:a}=me(e,wt),o=C(new Set),n=C(!1),y=r=>{const f=r.filter(D=>!e.settings.value.focusBlacklist.includes(D));if(f.length===o.value.size&&f.every(D=>o.value.has(D)))return;const A=new Set([...o.value]);o.value=new Set(f),e.emit("onFocusChange",o.value,A)},l=r=>{if(o.value.has(r)||e.settings.value.focusBlacklist.includes(r))return;const p=new Set([...o.value]);o.value.add(r),e.emit("onFocusChange",o.value,p)},m=r=>{var u,p;const f=Se(e.canvas);(p=(u=r.shape).activateTextArea)==null||p.call(u,f,A=>{const D=e.getEdge(r.id);if(!D)throw new Error("textarea only implemented for edges");const w=e.settings.value.edgeInputToLabel(A);w===void 0||D.label===w||(D.label=w,e.emit("onEdgeLabelChange",D),e.emit("onStructureChange",e.nodes.value,e.edges.value))})},h=()=>{const r=Array.from(o.value),f=r.filter(u=>e.getNode(u)||e.getEdge(u));f.length!==r.length&&y(f)},E=({items:r,coords:f})=>{var w,B;const u=r.at(-1);if(!u)return n.value?void 0:g();if(((B=(w=u.shape).textHitbox)==null?void 0:B.call(w,f))&&e.settings.value.edgeLabelsEditable&&u.graphType==="edge")return g(),m(u);At.some(T=>T===u.graphType)&&(n.value?l(u.id):y([u.id]))},g=()=>y([]),S=()=>{const r=e.nodes.value.map(u=>u.id),f=e.edges.value.map(u=>u.id);y([...r,...f])},v=({id:r},{focus:f})=>{f&&y([r])},i=r=>o.value.has(r);a("nodeColor",r=>{if(i(r.id))return e.getTheme("nodeFocusColor",r)}),a("nodeBorderColor",r=>{if(i(r.id))return e.getTheme("nodeFocusBorderColor",r)}),a("nodeTextColor",r=>{if(i(r.id))return e.getTheme("nodeFocusTextColor",r)}),a("edgeColor",r=>{if(i(r.id))return e.getTheme("edgeFocusColor",r)}),a("edgeTextColor",r=>{if(i(r.id))return e.getTheme("edgeFocusTextColor",r)}),a("nodeAnchorColor",r=>{if(i(r.id))return e.getTheme("nodeAnchorColorWhenParentFocused",r)});const c=r=>{r.key==="Shift"&&(n.value=!0)},b=r=>{r.key==="Shift"&&(n.value=!1)},d=()=>{e.subscribe("onNodeAdded",v),e.subscribe("onEdgeAdded",v),e.subscribe("onMouseDown",E),e.subscribe("onGraphReset",g),e.subscribe("onKeyDown",c),e.subscribe("onKeyUp",b),e.subscribe("onStructureChange",h)},N=()=>{e.unsubscribe("onNodeAdded",v),e.unsubscribe("onEdgeAdded",v),e.unsubscribe("onMouseDown",E),e.unsubscribe("onGraphReset",g),e.unsubscribe("onKeyDown",c),e.unsubscribe("onKeyUp",b),e.unsubscribe("onStructureChange",h),g()};return e.subscribe("onSettingsChange",r=>{r.focusable===!1?N():r.focusable===!0&&d()}),e.settings.value.focusable&&d(),{...e,focusedItemIds:$(o),setFocus:y,resetFocus:g,addToFocus:l,isFocused:i,focusAll:S,focusedNodes:U(()=>e.nodes.value.filter(r=>i(r.id))),focusedEdges:U(()=>e.edges.value.filter(r=>i(r.id)))}},Mt=(s,t={})=>{const e=Ct(s,t),a=C(),o=({items:h,coords:E})=>{const g=h.at(-1);if(!g||g.graphType!=="node")return;const S=e.getNode(g.id);S&&(a.value={node:S,coords:E},e.emit("onNodeDragStart",S))},n=()=>{a.value&&(e.emit("onNodeDrop",a.value.node),a.value=void 0)},y=({coords:h})=>{if(!a.value)return;const{node:E,coords:g}=a.value,S=h.x-g.x,v=h.y-g.y;e.moveNode(E.id,{x:E.x+S,y:E.y+v}),a.value.coords=h},l=()=>{e.subscribe("onMouseDown",o),e.subscribe("onMouseUp",n),e.subscribe("onMouseMove",y)},m=()=>{e.unsubscribe("onMouseDown",o),e.unsubscribe("onMouseUp",n),e.unsubscribe("onMouseMove",y),a.value&&n()};return e.subscribe("onSettingsChange",h=>{h.draggable===!1?m():h.draggable===!0&&l()}),e.settings.value.draggable&&l(),{...e,activeDragNode:U(()=>{var h;return(h=a.value)==null?void 0:h.node})}},It=(s,t={})=>{const e=Mt(s,t),a=C(),o=C(),n=()=>{a.value=void 0,o.value=void 0},y=u=>{if(e.activeDragNode.value)return[];const{getTheme:p}=e,A=p("nodeAnchorColor",u),D=p("nodeAnchorRadius",u),w=[];for(const B of l.value){const{x:T,y:M}=B,I={at:{x:T,y:M},radius:D,color:A};o.value&&o.value.direction===B.direction&&(I.at.x=o.value.x,I.at.y=o.value.y);const F=be(I);w.push({id:B.id,graphType:"node-anchor",shape:F,priority:1/0})}return w},l=C([]),m=u=>{if(!u)return l.value=[];const{getTheme:p}=e,A=p("nodeAnchorRadius",u),D=p("nodeSize",u),w=p("nodeBorderWidth",u),B=D-A/3+w/2;l.value=[{x:u.x,y:u.y-B,direction:"north"},{x:u.x+B,y:u.y,direction:"east"},{x:u.x,y:u.y+B,direction:"south"},{x:u.x-B,y:u.y,direction:"west"}].map(T=>({...T,id:Z()}))},h=({items:u})=>{const p=u.at(-1);if(!p||p.graphType!=="node-anchor")return;const{id:A}=p;return l.value.find(D=>D.id===A)},E=()=>{if(!a.value||!o.value)return;const{x:u,y:p}=o.value,A={x:a.value.x,y:a.value.y},D={x:u,y:p},{getTheme:w}=e,B=w("linkPreviewColor",a.value,o.value),T=w("linkPreviewWidth",a.value,o.value);return{id:"link-preview",graphType:"link-preview",shape:ye({start:A,end:D,color:B,width:T})}},g=({items:u})=>{if(o.value)return;const p=u.at(-1);if(!p)return n();if(p.graphType!=="node")return;const A=e.getNode(p.id);if(!A)throw new Error("node in aggregator but not in graph");const D=e.isFocused(A.id),w=e.focusedNodes.value.length>1;if(D&&w)return n();a.value=A,m(A)},S=u=>{if(!a.value)return;const p=h(u);p&&(o.value=p,e.emit("onNodeAnchorDragStart",a.value,p))},v=({coords:u})=>{if(!o.value)return;const{x:p,y:A}=u;o.value.x=p,o.value.y=A},i=()=>{if(o.value){if(!a.value)throw new Error("active anchor without parent node")}else return;e.emit("onNodeAnchorDrop",a.value,o.value),n()},c=u=>{if(!a.value)return u;const p=y(a.value);for(const A of p)u.push(A);return u},b=u=>{var B;if(!a.value||!o.value)return u;const{id:p}=a.value;pe(p,u);const A=(B=u.find(T=>T.id===p))==null?void 0:B.priority;if(!A)return u;const D=E();if(!D)return u;const w={...D,priority:A-.1};return u.push(w),u};e.updateAggregator.push(c),e.updateAggregator.push(b);const d=u=>{var p;((p=a.value)==null?void 0:p.id)===u.id&&n()},N=()=>{if(!a.value)return;const u=e.isFocused(a.value.id),p=e.focusedNodes.value.length>1;u&&p&&n()},r=()=>{e.subscribe("onNodeRemoved",d),e.subscribe("onNodeMoved",n),e.subscribe("onNodeDrop",m),e.subscribe("onMouseMove",g),e.subscribe("onMouseMove",v),e.subscribe("onMouseDown",S),e.subscribe("onMouseUp",i),e.subscribe("onFocusChange",N)},f=()=>{e.unsubscribe("onNodeRemoved",d),e.unsubscribe("onNodeMoved",n),e.unsubscribe("onNodeDrop",m),e.unsubscribe("onMouseMove",g),e.unsubscribe("onMouseMove",v),e.unsubscribe("onMouseDown",S),e.unsubscribe("onMouseUp",i),e.unsubscribe("onFocusChange",N)};return e.subscribe("onSettingsChange",u=>{u.nodeAnchors===!0?r():u.nodeAnchors===!1&&f()}),e.settings.value.nodeAnchors&&r(),{...e,nodeAnchorActiveAnchor:$(o),nodeAnchorParentNode:$(a)}},Dt="use-marquee-graph",Bt={THEME_ID:Dt},kt=(s,t={})=>{const e=It(s,t),a=C(),o=C(),n=C(),{setTheme:y,removeTheme:l}=me(e,Bt.THEME_ID),m=()=>y("nodeAnchorColor",J.TRANSPARENT),h=()=>l("nodeAnchorColor"),E=T=>{const{width:M,height:I}=T;return Math.abs(M*I)},g=({items:T,coords:M})=>{const I=T.at(-1);(I==null?void 0:I.graphType)!=="encapsulated-node-box"&&h(),I||b(M)},S=({items:T,coords:M})=>{if(!n.value)return;const I=T.at(-1);if((I==null?void 0:I.graphType)!=="encapsulated-node-box")return;const F=M.x-n.value.x,_=M.y-n.value.y;n.value=M;for(const L of e.focusedNodes.value)e.moveNode(L.id,{x:L.x+F,y:L.y+_});r()},v=({items:T,coords:M})=>{if(a.value)return;const I=T.at(-1);(I==null?void 0:I.graphType)==="encapsulated-node-box"&&(n.value=M,e.emit("onGroupDragStart",e.focusedNodes.value,M))},i=()=>{n.value&&(e.emit("onGroupDrop",e.focusedNodes.value,n.value),n.value=void 0)},c=()=>o.value={at:{x:1/0,y:1/0},width:0,height:0},b=T=>{m(),e.graphCursorDisabled.value=!0,a.value={at:T,width:0,height:0},c()},d=()=>{a.value&&(a.value=void 0,e.graphCursorDisabled.value=!1,h())},N=T=>{if(E(T)<100)return;const I=[];for(const{id:F,shape:_,graphType:L}of e.aggregator.value){const{marqueeSelectableGraphTypes:H}=e.settings.value;if(!H.includes(L))continue;_.efficientHitbox(T)&&I.push(F)}e.setFocus(I)},r=()=>{if(!o.value)return;if(e.focusedNodes.value.length<2)return c();let T=1/0,M=1/0,I=-1/0,F=-1/0;for(const _ of e.focusedNodes.value){const L=e.getTheme("nodeSize",_),H=e.getTheme("nodeBorderWidth",_),P=L+H/2,{x:z,y:R}=_;T=Math.min(T,z-P),M=Math.min(M,R-P),I=Math.max(I,z+P),F=Math.max(F,R+P)}T<1/0&&M<1/0&&I>-1/0&&F>-1/0?(o.value.at.x=T,o.value.at.y=M,o.value.width=I-T,o.value.height=F-M):(o.value.width=0,o.value.height=0)},f=({coords:T})=>{if(!a.value)return;const{x:M,y:I}=T;a.value.width=M-a.value.at.x,a.value.height=I-a.value.at.y,N(a.value)},u=T=>({id:"marquee-box",graphType:"marquee-box",shape:re({...T,color:e.getTheme("marqueeSelectionBoxColor"),stroke:{color:e.getTheme("marqueeSelectionBoxBorderColor"),width:2}}),priority:1/0}),p=T=>{if(!a.value)return T;const M=u(a.value);return T.push(M),T},A=T=>({id:"encapsulated-node-box",graphType:"encapsulated-node-box",shape:re({...T,color:e.getTheme("marqueeEncapsulatedNodeBoxColor"),stroke:{color:e.getTheme("marqueeEncapsulatedNodeBoxBorderColor"),width:2}}),priority:1/0}),D=T=>{if(!o.value)return T;const M=A(o.value);return T.push(M),T};e.updateAggregator.push(D),e.updateAggregator.push(p);const w=()=>{e.subscribe("onFocusChange",r),e.subscribe("onMouseDown",g),e.subscribe("onMouseUp",d),e.subscribe("onContextMenu",d),e.subscribe("onMouseMove",f),e.subscribe("onMouseDown",v),e.subscribe("onMouseUp",i),e.subscribe("onMouseMove",S),e.subscribe("onUndo",r),e.subscribe("onRedo",r)},B=()=>{e.unsubscribe("onFocusChange",r),e.unsubscribe("onMouseDown",g),e.unsubscribe("onMouseUp",d),e.unsubscribe("onContextMenu",d),e.unsubscribe("onMouseMove",f),e.unsubscribe("onMouseDown",v),e.unsubscribe("onMouseUp",i),e.unsubscribe("onMouseMove",S),e.unsubscribe("onUndo",r),e.unsubscribe("onRedo",r),a.value&&d()};return e.subscribe("onSettingsChange",T=>{T.marquee===!0?w():T.marquee===!1&&B()}),e.settings.value.marquee&&w(),{...e,updateEncapsulatedNodeBox:r}},Rt=(s,t={})=>{const e=kt(s,t),a=C(ke[0]),o=C(Re[1]),n=C(!1),y=C(new Set),l=C([]),m=C([]),h=C(!1),E=C(),g=C(!1),S=()=>{m.value=[]},v=({coords:r})=>{h.value=!0,E.value=r,l.value=[r]},i=({coords:r})=>{if(!(!h.value||!E.value)){if(n.value){const f=m.value.filter(u=>j.scribble(u).hitbox(r));for(const u of f)y.value.add(u.id);return}E.value=r,l.value.push(r)}},c=()=>{if(h.value&&(h.value=!1,E.value=void 0,l.value.length!==0)){if(n.value){m.value=m.value.filter(r=>!y.value.has(r.id)),y.value.clear();return}m.value.push({id:Z(),type:"draw",points:l.value,color:a.value,brushWeight:o.value}),l.value=[]}};V(n,()=>{e.canvas.value&&(e.canvas.value.style.cursor=n.value?"none":"crosshair")});const b=r=>{if(!g.value)return r;if(n.value){const f=j.circle({at:e.graphAtMousePosition.value.coords,radius:10,color:J.TRANSPARENT,stroke:{color:J.WHITE+"60",width:2}});r.push({graphType:"annotation",id:f.id,shape:f,priority:5050})}else if(l.value.length>0){const f=j.scribble({type:"draw",points:l.value,color:a.value,brushWeight:o.value});r.push({graphType:"annotation",id:f.id,shape:f,priority:5001})}for(const f of m.value){const u=y.value.has(f.id);r.push({graphType:"annotation",id:f.id,shape:j.scribble({...f,color:f.color+(u?"50":"")}),priority:5e3})}return r};return e.updateAggregator.push(b),{...e,clearAnnotations:S,annotationActive:g,annotationErasing:n,annotationColor:a,annotationBrushWeight:o,activateAnnotation:()=>{e.canvas.value&&(g.value=!0,e.settings.value.userEditable=!1,e.settings.value.marquee=!1,e.settings.value.focusable=!1,e.graphCursorDisabled.value=!0,e.canvas.value.style.cursor="crosshair",e.subscribe("onMouseDown",v),e.subscribe("onMouseMove",i),e.subscribe("onMouseUp",c))},deactivateAnnotation:()=>{e.canvas.value&&(g.value=!1,n.value=!1,e.settings.value.userEditable=!0,e.settings.value.marquee=!0,e.settings.value.focusable=!0,e.graphCursorDisabled.value=!1,e.canvas.value.style.cursor="default",e.unsubscribe("onMouseDown",v),e.unsubscribe("onMouseMove",i),e.unsubscribe("onMouseUp",c))}}},Ft=(s=!1)=>{const t=l=>l.key===" "?"Space":l.key.length>1||s?l.key:l.key.toUpperCase(),e=C(""),a=U(()=>{let l;return e.value.split("+").filter(m=>{const h=m===l;return l=m,!h}).join("+")}),o=l=>{e.value.length>0&&(e.value+="+"),e.value+=t(l)},n=()=>{e.value=""},y=l=>a.value===l;return document.addEventListener("keydown",o),document.addEventListener("keyup",n),he(()=>{document.removeEventListener("keydown",o),document.removeEventListener("keyup",n)}),{isPressed:y,currentKeyString:e}},Ot=(s,t={})=>{const e=Rt(s,t),a=({coords:v,event:i})=>{e.addNode(v),setTimeout(()=>e.updateGraphAtMousePosition(i),10)},o=(v,i)=>{const b=e.getSchemaItemsByCoordinates(i).findLast(N=>N.graphType==="node");if(!b)return;const d=e.getNode(b.id);if(d&&!(e.settings.value.userAddedEdgeRuleNoSelfLoops&&v.id===d.id)){if(e.settings.value.userAddedEdgeRuleOneEdgePerPath){const N=e.edges.value.find(u=>u.from===v.id&&u.to===d.id),r=e.edges.value.find(u=>u.from===d.id&&u.to===v.id);if(N||r)return}e.addEdge({from:v.id,to:d.id,label:e.settings.value.userAddedEdgeLabel})}},n=()=>{e.bulkRemoveNode([...e.focusedItemIds.value]),e.bulkRemoveEdge([...e.focusedItemIds.value])},y={Mac:{"Meta+Z":()=>e.undo(),"Shift+Meta+Z":()=>e.redo(),Backspace:n,"Meta+A":e.focusAll,Escape:e.resetFocus},Windows:{"Control+Z":()=>e.undo(),"Shift+Control+Z":()=>e.redo(),Backspace:n,"Control+A":e.focusAll,Escape:e.resetFocus}},l=window.navigator.userAgent.includes("Mac")?"Mac":"Windows",{isPressed:m}=Ft(),E={onDblClick:a,onKeyDown:()=>{if(e.settings.value.userEditable===!1||e.canvasFocused.value===!1)return;const v=y[l];for(const i in v)m(i)&&v[i]()},onNodeAnchorDrop:o},g=()=>{for(const v in E)e.subscribe(v,E[v]);e.settings.value.nodeAnchors=!0,e.settings.value.edgeLabelsEditable=!0},S=()=>{for(const v in E)e.unsubscribe(v,E[v]);e.settings.value.nodeAnchors=!1,e.settings.value.edgeLabelsEditable=!1};return e.settings.value.userEditable&&g(),e.subscribe("onSettingsChange",v=>{v.userEditable===!0?g():v.userEditable===!1&&S()}),e},_t=(s,t={})=>{const e=Ot(s,t),a={get:()=>JSON.parse(localStorage.getItem(e.settings.value.persistentStorageKey+"-nodes")??"[]"),set:g=>{const S=g.filter(v=>!e.settings.value.persistentBlacklist.has(v.id));localStorage.setItem(e.settings.value.persistentStorageKey+"-nodes",JSON.stringify(S))}},o={get:()=>JSON.parse(localStorage.getItem(e.settings.value.persistentStorageKey+"-edges")??"[]"),set:g=>{const S=g.filter(v=>!e.settings.value.persistentBlacklist.has(v.id));localStorage.setItem(e.settings.value.persistentStorageKey+"-edges",JSON.stringify(S))}},n=async()=>{await new Promise(g=>setTimeout(g,10)),a.set(e.nodes.value),o.set(e.edges.value)},y=()=>{e.nodes.value=a.get(),e.edges.value=o.get(),queueMicrotask(()=>e.emit("onStructureChange",e.nodes.value,e.edges.value))},l=["onStructureChange","onNodeDrop","onGroupDrop","onGraphReset","onEdgeLabelChange"],m=()=>{l.forEach(g=>e.subscribe(g,n))},h=()=>{l.forEach(g=>e.unsubscribe(g,n))},E=()=>{h()};return e.subscribe("onSettingsChange",g=>{if(E(),"persistent"in g&&!g.persistent)return;if("persistent"in g&&g.persistent){y(),m();return}"persistentStorageKey"in g&&y(),m()}),e.settings.value.persistent&&(y(),m()),{...e,trackGraphState:n}},Lt=s=>({getConnectedNodes:t=>Q(t,s),getConnectedEdges:t=>ve(t,s),getInboundEdges:t=>Fe(t,s),getOutboundEdges:t=>Oe(t,s),isEdgeFlowingIntoNode:(t,e)=>_e(t,e,s),isEdgeFlowingOutOfNode:(t,e)=>Le(t,e,s),getEdgesAlongPath:(t,e)=>fe(t,e,s),getEdgeWeight:t=>Ge(t,s),getWeightBetweenNodes:(t,e)=>Pe(t,e,s)}),Ut=(s,t={})=>{const e=_t(s,t),a=Lt(e),o={...e,helpers:a},n=K((t==null?void 0:t.theme)??{});return Je(o,n),o},Wt=Ue({__name:"Graph",props:{graph:{}},emits:["graphRef"],setup(s,{emit:t}){const e=s,a=t,o=l=>a("graphRef",l),n=C(e.graph.getTheme("graphBgPatternColor")),y=C(e.graph.getTheme("graphBgColor"));return e.graph.subscribe("onThemeChange",l=>{const{graphBgPatternColor:m,graphBgColor:h}=l;m&&(n.value=m),h&&(y.value=h)}),(l,m)=>(We(),He(Ve,{onCanvasRef:o,color:y.value,"pattern-color":n.value},null,8,["color","pattern-color"]))}});export{ee as T,Wt as _,tt as i,Ut as u};
