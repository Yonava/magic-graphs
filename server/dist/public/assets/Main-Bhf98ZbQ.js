var G=Object.defineProperty;var W=(s,t,e)=>t in s?G(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e;var p=(s,t,e)=>W(s,typeof t!="symbol"?t+"":t,e);import{g as Y,u as K}from"./Graph.vue_vue_type_script_setup_true_lang-C7aWDySR.js";import{a as C,b as $,_ as X}from"./GraphProduct.vue_vue_type_script_setup_true_lang-D1wvnyRJ.js";import{d as A,g as _,o as w,c as j,b as v,w as h,e as N,t as R,J as B,K as k,a as I,B as D,x as H,z as d,V as F,A as U,y as m,E as y,W as z}from"./index-Wvoc3Gvc.js";import{_ as L}from"./GHoverInfoTop.vue_vue_type_script_setup_true_lang-Dly99hEe.js";import{t as J}from"./ResponsiveCanvas.vue_vue_type_script_setup_true_lang-jduWpegf.js";import{g as q}from"./getTreeBinaryPos-BjgHcT-j.js";import"./Button.vue_vue_type_script_setup_true_lang-Dt14VFd8.js";import"./Icon.vue_vue_type_script_setup_true_lang-BBvBH1WR.js";import"./TutorialHint.vue_vue_type_script_setup_true_lang-C3Zn5Vyd.js";import"./GHoverInfo.vue_vue_type_script_setup_true_lang-wR7Lbjsj.js";const Q={persistentStorageKey:"binary-trees",displayEdgeLabels:!1},Z={class:"flex flex-col gap-3"},tt=A({__name:"CRUDControls",props:{tree:{}},setup(s){const t=s,e=_(1),o=_(1),i=()=>{t.tree.insertNode(e.value++)},a=()=>{t.tree.removeNode(o.value)};return(r,l)=>(w(),j("div",Z,[v($,{secondary:"",class:"rounded-lg flex gap-2 p-2"},{default:h(()=>[v(C,{onClick:i,tertiary:""},{default:h(()=>[N(" Add Node ("+R(e.value)+") ",1),B(I("input",{onClick:l[0]||(l[0]=D(()=>{},["stop"])),"onUpdate:modelValue":l[1]||(l[1]=u=>e.value=u),class:"w-12 bg-transparent"},null,512),[[k,e.value,void 0,{number:!0}]])]),_:1}),v(C,{onClick:a,tertiary:""},{default:h(()=>[N(" Remove Node ("+R(o.value)+") ",1),B(I("input",{onClick:l[2]||(l[2]=D(()=>{},["stop"])),"onUpdate:modelValue":l[3]||(l[3]=u=>o.value=u),class:"w-12 bg-transparent"},null,512),[[k,o.value,void 0,{number:!0}]])]),_:1}),v(C,{onClick:r.tree.balanceTree,tertiary:""},{default:h(()=>l[4]||(l[4]=[N(" Balance Tree ")])),_:1},8,["onClick"])]),_:1})]))}}),et="node-labeller",O=(s,t,e=et)=>{const o=n=>typeof t=="function"?t(n):"value"in t?t.value.get(n):t.get(n),{setTheme:i,removeTheme:a}=H(s,e),r=n=>{if(s.focus.isFocused(n.id))return;const c=o(n.id);if(c!==void 0)return c.toString()};return{label:()=>{i("nodeText",r)},unlabel:()=>{a("nodeText")},get:o}},rt="node-colorer",V=(s,t,e=rt)=>{const o=n=>typeof t=="function"?t(n):"value"in t?t.value.get(n):t.get(n),{setTheme:i,removeTheme:a}=H(s,e),r=n=>{if(!s.focus.isFocused(n.id))return o(n.id)};return{color:()=>{i("nodeBorderColor",r),i("nodeAnchorColor",r)},uncolor:()=>{a("nodeBorderColor"),a("nodeAnchorColor")},get:o}},ot=(s,t)=>{const{nodeIdToBalanceFactor:e}=t,o={[-1]:d.YELLOW_500,0:d.GREEN_600,1:d.YELLOW_500},i=d.RED_600,a=g=>o[e.value.get(g)??0]??i,{label:r,unlabel:l}=O(s,e),{color:u,uncolor:n}=V(s,a);return{activate:()=>{r(),u()},deactivate:()=>{l(),n()}}},{interpolate:st}=Y.utils,it=s=>{const[t,e]=s.range,o=Array.isArray(s.color)?s.color[0]:s.color,i=Array.isArray(s.color)?s.color[1]:J(s.color).darken(50).toString(),a=st(o,i);return r=>{const l=(r-t)/(e-t);return l<0?o:l>1?i:a(l)}},lt=(s,t)=>{const{nodeIdToHeight:e}=t,o=it({range:[1,6],color:[d.GREEN_400,d.GREEN_700]}),i=f=>o(e.value.get(f)??0),{label:a,unlabel:r}=O(s,e),{color:l,uncolor:u}=V(s,i);return{activate:()=>{a(),l()},deactivate:()=>{r(),u()}}},at=A({__name:"TreeInfoLabels",props:{tree:{}},setup(s){const t=s,{activate:e,deactivate:o}=ot(F.value,t.tree),{activate:i,deactivate:a}=lt(F.value,t.tree),r={balanceFactor:"The balance factor of a node is the height of its right subtree minus the height of its left subtree.",height:"The height of a node is the number of edges on the longest path from the node to a leaf."};return(l,u)=>(w(),U($,{secondary:"",class:"p-2 rounded-lg flex flex-wrap gap-2"},{default:h(()=>[v(L,{onMouseenter:m(e),onMouseleave:m(o),tooltip:r.balanceFactor},{default:h(()=>u[0]||(u[0]=[N(" Balance Factor ")])),_:1},8,["onMouseenter","onMouseleave","tooltip"]),v(L,{onMouseenter:m(i),onMouseleave:m(a),tooltip:r.height},{default:h(()=>u[1]||(u[1]=[N(" Height ")])),_:1},8,["onMouseenter","onMouseleave","tooltip"])]),_:1}))}}),nt=({root:s,treeDepth:t})=>{const e=[];if(!s)return e;let o=[s];for(let i=0;i<=t;i++){const a=[];for(const r of o)e.push(r),a.push(r==null?void 0:r.left),a.push(r==null?void 0:r.right);o=[...a]}return e};class E{constructor(t){p(this,"key");p(this,"left");p(this,"right");p(this,"height");this.key=t,this.left=void 0,this.right=void 0,this.height=1}}const b=s=>s?s.height:0,T=s=>{const t=b(s==null?void 0:s.left),e=b(s==null?void 0:s.right);return t-e};class ct{constructor(){p(this,"root");this.root=void 0}getNode(t){let e=this.root;for(;e;){if(t===e.key)return e;t<e.key?e=e.left:e=e.right}}updateHeight(t){t.height=Math.max(b(t.left),b(t.right))+1}removeMin(t){return t.left?(t.left=this.removeMin(t.left),this.updateHeight(t),t):t.right}findMin(t){let e=t;for(;e.left;)e=e.left;return e}remove(t){if(!this.root)return[];const e=[];let o=!1;const i=(a,r,l,u)=>{if(r){if(o||e.push({action:"compare",treeNodeKey:r.key,treeState:this.toArray()}),l<r.key&&!o)r.left=i(r,r.left,l,!0);else if(l>r.key&&!o)r.right=i(r,r.right,l,!1);else{o=!0;let n;if(!r.left&&!r.right)n=void 0;else if(!r.left)n=r.right;else if(!r.right)n=r.left;else{const c=this.findMin(r.right);n=new E(c.key),n.left=r.left,n.right=this.removeMin(r.right),n.height=r.height}return a?u?a.left=n:a.right=n:this.root=n,e.push({action:"remove",treeState:this.toArray()}),a?u?a.left=r:a.right=r:this.root=r,n}return r&&(this.updateHeight(r),this.rebalance(a,r,u,e))}};return this.root=i(void 0,this.root,t,!1),e}rebalance(t,e,o,i){const a=T(e);if(a>1&&T(e.left)>=0){const r=this.rotateRight(e);return t?o?t.left=r:t.right=r:this.root=r,i.push({action:"balance",method:"left-left",treeState:this.toArray()}),t?o?t.left=e:t.right=e:this.root=e,r}if(a<-1&&T(e.right)<=0){const r=this.rotateLeft(e);return t?o?t.left=r:t.right=r:this.root=r,i.push({action:"balance",method:"right-right",treeState:this.toArray()}),t?o?t.left=e:t.right=e:this.root=e,r}if(a>1&&T(e.left)<0){e.left=this.rotateLeft(e.left);const r=this.rotateRight(e);return t?o?t.left=r:t.right=r:this.root=r,i.push({action:"balance",method:"left-right",treeState:this.toArray()}),t?o?t.left=e:t.right=e:this.root=e,r}if(a<-1&&T(e.right)>0){e.right=this.rotateRight(e.right);const r=this.rotateLeft(e);return t?o?t.left=r:t.right=r:this.root=r,i.push({action:"balance",method:"right-left",treeState:this.toArray()}),t?o?t.left=e:t.right=e:this.root=e,r}return e}balance(){const t=[],e=(o,i,a)=>{if(i)return i.left=e(i,i.left,!0),i.right=e(i,i.right,!1),this.updateHeight(i),this.rebalance(o,i,a,t)};return this.root=e(void 0,this.root,!1),t}toArray(){return nt({root:this.root,treeDepth:b(this.root)}).map(t=>t==null?void 0:t.key)}rotateRight(t){const e=t.left,o=e.right;return e.right=t,t.left=o,this.updateHeight(t),this.updateHeight(e),e}rotateLeft(t){const e=t.right,o=e.left;return e.left=t,t.right=o,this.updateHeight(t),this.updateHeight(e),e}insert(t,e=!0){if(!this.root)return this.root=new E(t),[{action:"insert",treeState:this.toArray()}];const o=[];let i=!1;const a=(r,l,u,n)=>{if(!l){const c=new E(u);return i=!0,c}if(o.push({action:"compare",treeNodeKey:l.key,treeState:this.toArray()}),u<l.key)l.left=a(l,l.left,u,!0),i&&(o.push({action:"insert",treeState:this.toArray()}),i=!1);else if(u>l.key)l.right=a(l,l.right,u,!1),i&&(o.push({action:"insert",treeState:this.toArray()}),i=!1);else return l;return this.updateHeight(l),e?this.rebalance(r,l,n,o):l};return this.root=a(void 0,this.root,t,!1),o}}const ut=d.AMBER_600,ft=s=>{const{setTheme:t,removeAllThemes:e}=H(s,"tree"),o=_(),i=l=>{if(o.value&&!s.focus.isFocused(l.id)&&l.id===o.value.id)return ut};return{activate:l=>{l&&(o.value=l),t("nodeBorderColor",i),t("nodeAnchorColor",i)},deactivate:()=>{o.value=void 0,e()},targetNode:o}},P=(s,t)=>({from:s.toString(),to:t.toString(),id:`${s}-${t}`,label:""}),ht=(s,t)=>{const e=[];for(let o=0;o<t.length;o++){const i=t[o];if(!i)continue;const a=t[2*o+1],r=t[2*o+2];a&&e.push(P(i,a)),r&&e.push(P(i,r))}return e},gt=async(s,t,e,o)=>{const i=ht(s,t),a=s.edges.value.filter(c=>!i.some(f=>f.id===c.id)),r=s.nodes.value.filter(c=>!t.includes(parseInt(c.id)));if(await Promise.all(r.map(c=>s.removeNode(c.id,{animate:!0}))),!e)return;const l=e.height,n=q({rootCoordinate:o,xOffset:{2:175,3:135,4:100}[l]??80,yOffset:200,treeDepth:l});await Promise.all(t.map((c,f)=>{if(!(!c||s.getNode(c.toString())))return s.addNode({id:c.toString(),label:c.toString(),...n[f]},{animate:!0,focus:!1})})),await Promise.all(a.map(c=>s.removeEdge(c.id,{animate:!0}))),await new Promise(c=>setTimeout(c,500)),await Promise.all(t.map((c,f)=>{if(!c)return;const g=s.getNode(c.toString());g&&(g.x===n[f].x&&g.y===n[f].y||s.animate.node({nodeId:g.id,endCoords:n[f],durationMs:750}))}));for(const c of i)await s.addEdge(c,{animate:!0})},vt={x:2300,y:1500},dt=(s,t)=>{const{targetNode:e,activate:o}=ft(s);o();const i=_([]),a=y(()=>i.value),r=z(a);return r.onStepChange(l=>{e.value=void 0;const u=a.value[l];if(gt(s,u.treeState,t.root,vt),u.action==="compare"){const{treeNodeKey:n}=u,c=s.getNode(n.toString());c&&(e.value=c)}}),{sim:r,currTrace:i}},mt=s=>{const t=new ct,{currTrace:e,sim:o}=dt(s,t),i=f=>{o.stop(),e.value=t.insert(f,!1),o.start()},a=()=>{o.stop(),e.value=t.balance(),o.playbackSpeed.value=2e3,e.value.length!==0&&o.start()},r=f=>{o.stop(),e.value=t.remove(f),o.start()},l=f=>s.nodes.value.reduce((S,M)=>{const x=t.getNode(Number(M.id));return x&&S.set(M.id,f(x)),S},new Map),u=y(()=>l(T)),n=y(()=>l(b));return{tree:t,insertNode:i,removeNode:r,balanceTree:a,nodeIdToBalanceFactor:u,nodeIdToHeight:n,getRoot:()=>{const{root:f}=t;if(f)return s.getNode(f.toString())}}},Ht=A({__name:"Main",setup(s){const t=_(),e=K(t,Q),o=mt(e);return(i,a)=>(w(),U(X,{onGraphRef:a[0]||(a[0]=r=>t.value=r),graph:m(e)},{"top-center":h(()=>[v(tt,{tree:m(o)},null,8,["tree"])]),"bottom-center":h(()=>[v(at,{tree:m(o)},null,8,["tree"])]),_:1},8,["graph"]))}});export{Ht as default};
