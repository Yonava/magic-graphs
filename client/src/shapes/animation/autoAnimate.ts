import type { DefineTimeline } from "./timeline/define";
import type { SchemaId, ShapeName } from "@shape/types";

export const AUTO_ANIMATE_DURATION_MS = 500;
const AUTO_ANIMATED_PROPERTIES = new Set(['at', 'start', 'end', 'lineWidth', 'radius', 'fillColor'])

export const useAutoAnimate = (defineTimeline: DefineTimeline) => {
  let capturedSchema: Record<string, any>[] = []
  let activelyCapturingSchemas = false;

  const activeAnimationStopper: Map<`${SchemaId}-${string}`, () => void> = new Map()

  const isEqual = (val1: any, val2: any) => {
    if (typeof val1 !== typeof val2) return false;
    if (typeof val1 !== 'object' || val1 === null || val2 === null) {
      return val1 === val2;
    }
    return JSON.stringify(val1) === JSON.stringify(val2);
  }

  const clone = <T>(obj: T): T => JSON.parse(JSON.stringify(obj)) as T;

  const applyAutoAnimate = (schemaBefore: any, schemaAfter: any, shapeName: any) => {
    const shapeId = schemaAfter.id

    const animateProperty = (startVal: any, endVal: any, propName: string) => {
      const stopper = activeAnimationStopper.get(`${shapeId}-${propName}`)
      if (stopper) stopper()

      const { play, stop } = defineTimeline({
        forShapes: [shapeName],
        durationMs: AUTO_ANIMATE_DURATION_MS,
        easing: { [propName]: 'in-out' },
        keyframes: [
          {
            progress: 0,
            properties: { [propName]: clone(startVal) }
          },
          {
            progress: 1,
            properties: { [propName]: clone(endVal) }
          }
        ],
      })

      play({ shapeId: schemaAfter.id, runCount: 1 })
      activeAnimationStopper.set(`${shapeId}-${propName}`, () => stop({ shapeId }))
    }

    const initialProperties: Record<string, any> = {}
    for (const [propName, startVal] of Object.entries(schemaBefore)) {
      if (!AUTO_ANIMATED_PROPERTIES.has(propName)) continue

      const endVal = schemaAfter[propName];
      if (isEqual(startVal, endVal)) continue

      animateProperty(startVal, endVal, propName)

      initialProperties[propName] = startVal
    }

    if (Object.keys(initialProperties).length === 0) return

    return {
      ...schemaAfter,
      ...initialProperties,
    }
  }

  return {
    captureSchemaState: (schema: any, shapeName: ShapeName) => {
      if (!activelyCapturingSchemas || !schema?.id) return
      capturedSchema.push({ ...clone(schema), shapeName })
    },
    applyAutoAnimate,
    autoAnimate: {
      /**
       * Captures a pair of "before" and "after" snapshots of the given shapes' schemas
       * by invoking the provided `flushDraw` function twice.
       *
       * This enables automatic animations to be generated by diffing the two states.
       *
       * @param ids - The IDs of shapes to track during this animation frame.
       * @param flushDraw - A function that triggers a draw cycle. This is called:
       *   - once immediately to capture the "before" state, and
       *   - again inside the returned `finalize()` function to capture the "after" state.
       *
       * @returns A function that, when called, finalizes the capture and triggers animation.
       *
       * @example
       * const finalize = autoAnimate.captureFrame(ids, () => draw());
       * mutateShapes();
       * finalize(); // triggers animation between captured states
       */
      captureFrame: (callback: () => void) => {
        capturedSchema = []
        activelyCapturingSchemas = true;
        callback()
        activelyCapturingSchemas = false;
        const before = capturedSchema

        return () => {
          capturedSchema = []
          activelyCapturingSchemas = true
          callback()
          activelyCapturingSchemas = false;
          const after = capturedSchema

          // apply animation by diffing before and after

          if (before.length !== after.length) {
            throw new Error('tracked shape mismatch when capturing animation frame')
          }

          for (let i = 0; i < after.length; i++) {
            applyAutoAnimate(before[i], after[i], after[i]['shapeName'])
          }
        }
      }
    }
  }
}

export type AutoAnimateControls = ReturnType<typeof useAutoAnimate>['autoAnimate']